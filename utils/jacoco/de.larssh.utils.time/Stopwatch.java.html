<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Stopwatch.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Utilities</a> &gt; <a href="index.source.html" class="el_package">de.larssh.utils.time</a> &gt; <span class="el_source">Stopwatch.java</span></div><h1>Stopwatch.java</h1><pre class="source lang-java linenums">// Generated by delombok at Mon Apr 10 13:32:28 UTC 2023
package de.larssh.utils.time;

import static de.larssh.utils.function.ThrowingConsumer.throwing;
import static java.util.Collections.synchronizedList;
import static java.util.Collections.unmodifiableList;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.TemporalAccessor;
import java.time.temporal.TemporalField;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.stream.Stream;
import de.larssh.utils.Nullables;
import edu.umd.cs.findbugs.annotations.Nullable;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * Implementation of a synchronized stopwatch starting at {@link Instant#now()}.
 * {@link #sinceStart()} can be used to retrieve the duration since the
 * stopwatch started.
 *
 * &lt;p&gt;
 * {@link #checkpoint(String)} adds a new checkpoint. It might be used for split
 * or lap times. {@link #sinceLast()} can be used to retrieve the duration since
 * the last checkpoint was created.
 */
public class Stopwatch {
	/**
	 * List of checkpoints
	 */
	private final List&lt;Checkpoint&gt; checkpoints = synchronizedList(new LinkedList&lt;&gt;());
	/**
	 * Instant at the stopwatches start
	 */
	private final Instant startInstant = Instant.now();
	/**
	 * Object used for locking
	 */
	private final Object lock = new Object();

	/**
	 * Adds a new checkpoint referenced by {@code name}.
	 *
	 * &lt;p&gt;
	 * {@code name} does not need to be unique. Multiple checkpoints with the same
	 * name might exist.
	 *
	 * @param name name to reference the checkpoint
	 * @return the new checkpoint
	 */
	public Checkpoint checkpoint(final String name) {
<span class="nc" id="L57">		synchronized (lock) {</span>
<span class="nc" id="L58">			final Checkpoint checkpoint = new Checkpoint(this, name, Instant.now(), getLastCheckpoint());</span>
<span class="nc" id="L59">			checkpoints.add(checkpoint);</span>
<span class="nc" id="L60">			return checkpoint;</span>
		}
	}

	/**
	 * List of checkpoints
	 *
	 * @return the list of checkpoints
	 */
	public List&lt;Checkpoint&gt; getCheckpoints() {
<span class="nc" id="L70">		return unmodifiableList(checkpoints);</span>
	}

	/**
	 * The last created {@link Checkpoint} or empty if no checkpoint was created
	 *
	 * @return the last created checkpoint
	 */
	public Optional&lt;Checkpoint&gt; getLastCheckpoint() {
<span class="nc bnc" id="L79" title="All 2 branches missed.">		return checkpoints.isEmpty() ? Optional.empty() : Optional.of(checkpoints.get(checkpoints.size() - 1));</span>
	}

	/**
	 * Instant of the last created {@link Checkpoint} or the stopwatches starting
	 * time if no checkpoint was created
	 *
	 * @return the last created instant or the stopwatches starting time
	 */
	public Instant getLastInstant() {
<span class="nc bnc" id="L89" title="All 2 branches missed.">		return checkpoints.isEmpty() ? getStartInstant() : checkpoints.get(checkpoints.size() - 1).getInstant();</span>
	}

	/**
	 * Duration since the last created {@link Checkpoint} or the stopwatches
	 * starting time if no checkpoint was created
	 *
	 * @return the duration since last checkpoints instant or the stopwatches
	 *         starting time
	 */
	public Duration sinceLast() {
<span class="nc" id="L100">		return Duration.between(getLastInstant(), Instant.now());</span>
	}

	/**
	 * Duration since the stopwatches start
	 *
	 * @return the duration since the stopwatches start
	 */
	public Duration sinceStart() {
<span class="nc" id="L109">		return Duration.between(getStartInstant(), Instant.now());</span>
	}

	/**
	 * Waits for {@code duration} using {@code Thread#sleep(long)}. If reached, it
	 * times out at {@code timeoutSinceStart} after the {@link Stopwatch} start.
	 *
	 * @param duration          duration to wait
	 * @param timeoutSinceStart timeout duration since the {@link Stopwatch} start
	 * @return {@code true} if the timeout was not reached and {@code false} if the
	 *         timeout has been reached
	 * @throws InterruptedException if any thread has interrupted the current thread
	 */
	@SuppressWarnings(&quot;unused&quot;)
	@SuppressFBWarnings(value = &quot;MDM_THREAD_YIELD&quot;, justification = &quot;This is really intended to sleep for a specified duration.&quot;)
	public boolean waitFor(final Duration duration, final Duration timeoutSinceStart) throws InterruptedException {
<span class="nc" id="L125">		return waitFor(duration, timeoutSinceStart, throwing(waiting -&gt; Thread.sleep(Nullables.orElseThrow(waiting).toMillis())));</span>
	}

	/**
	 * Waits for {@code duration} using {@code wait}. If reached, it times out at
	 * {@code timeoutSinceStart} after the {@link Stopwatch} start.
	 *
	 * &lt;p&gt;
	 * Note: The {@link Duration} given to {@code wait} might be less than
	 * {@code duration} to handle {@code timeoutSinceStart} more precisely.
	 *
	 * @param duration          duration to wait
	 * @param timeoutSinceStart timeout duration since the {@link Stopwatch} start
	 * @param wait              method to use for waiting
	 * @return {@code true} if the timeout was not reached and {@code false} if the
	 *         timeout has been reached
	 */
	@SuppressFBWarnings(value = &quot;PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS&quot;, justification = &quot;no redundant calls, because Instant.now() might return different values&quot;)
	public boolean waitFor(final Duration duration, final Duration timeoutSinceStart, final Consumer&lt;Duration&gt; wait) {
<span class="nc bnc" id="L144" title="All 2 branches missed.">		if (duration.isNegative()) {</span>
<span class="nc" id="L145">			throw new IllegalArgumentException(String.format(&quot;Parameter \&quot;duration\&quot; must not be negative, but is %s.&quot;, duration));</span>
		}
<span class="nc bnc" id="L147" title="All 2 branches missed.">		if (timeoutSinceStart.isNegative()) {</span>
<span class="nc" id="L148">			throw new IllegalArgumentException(String.format(&quot;Parameter \&quot;timeoutSinceStart\&quot; must not be negative, but is %s.&quot;, timeoutSinceStart));</span>
		}
<span class="nc" id="L150">		final Instant timeout = getStartInstant().plus(timeoutSinceStart);</span>
<span class="nc" id="L151">		final Duration maxWaiting = Duration.between(Instant.now(), timeout);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">		final Duration actualWaiting = maxWaiting.compareTo(duration) &gt; 0 ? duration : maxWaiting;</span>
<span class="nc bnc" id="L153" title="All 4 branches missed.">		if (!actualWaiting.isNegative() &amp;&amp; !actualWaiting.isZero()) {</span>
<span class="nc" id="L154">			wait.accept(actualWaiting);</span>
		}
<span class="nc bnc" id="L156" title="All 2 branches missed.">		return !Instant.now().isAfter(timeout);</span>
	}

	/**
	 * Sequential {@code Stream} with the checkpoints as its source
	 *
	 * @return a sequential {@code Stream} over the checkpoints
	 */
	public Stream&lt;Checkpoint&gt; stream() {
<span class="nc" id="L165">		return checkpoints.stream();</span>
	}


	/**
	 * Implementation of a stopwatches checkpoint. It might be used for split or lap
	 * times.
	 */
	public static class Checkpoint implements Comparable&lt;Checkpoint&gt;, TemporalAccessor {
		/**
		 * Comparator of {@link Checkpoint}
		 */
<span class="nc" id="L177">		private static final Comparator&lt;Checkpoint&gt; COMPARATOR = Comparator.comparing(Checkpoint::getInstant).thenComparing(Comparator.comparing(checkpoint -&gt; checkpoint.getPreviousCheckpoint().map(Checkpoint::getInstant).orElse(Instant.MIN)));</span>
		/**
		 * Stopwatch
		 *
		 * @return the stopwatch
		 */
		private final Stopwatch stopwatch;
		/**
		 * Checkpoints name as reference
		 *
		 * @return the checkpoints name
		 */
		private final String name;
		/**
		 * Instant
		 *
		 * @return the instant
		 */
		private final Instant instant;
		/**
		 * Previous checkpoint or empty if this is the stopwatches first checkpoint
		 *
		 * @return the previous checkpoint
		 */
		private final Optional&lt;Checkpoint&gt; previousCheckpoint;

		/** {@inheritDoc} */
		@Override
		public int compareTo(@Nullable final Checkpoint object) {
<span class="nc" id="L206">			return Objects.compare(this, object, COMPARATOR);</span>
		}

		/** {@inheritDoc} */
		@Override
		public long getLong(@Nullable final TemporalField field) {
<span class="nc" id="L212">			return getInstant().getLong(field);</span>
		}

		/**
		 * Instant of the previous {@link Checkpoint} or the stopwatches starting time
		 * if this is the first checkpoint
		 *
		 * @return the previous checkpoints instant or the stopwatches starting time
		 */
		public Instant getPreviousInstant() {
<span class="nc" id="L222">			return getPreviousCheckpoint().map(Checkpoint::getInstant).orElseGet(getStopwatch()::getStartInstant);</span>
		}

		/** {@inheritDoc} */
		@Override
		public boolean isSupported(@Nullable final TemporalField field) {
<span class="nc" id="L228">			return getInstant().isSupported(field);</span>
		}

		/**
		 * Duration between this checkpoint and the previous {@link Checkpoint} or the
		 * stopwatches starting time if this is the first checkpoint
		 *
		 * @return the duration between this checkpoint and previous checkpoints instant
		 *         or the stopwatches starting time
		 */
		public Duration sincePrevious() {
<span class="nc" id="L239">			return Duration.between(getPreviousInstant(), getInstant());</span>
		}

		/**
		 * Duration between this checkpoint and the stopwatches start
		 *
		 * @return the duration between this checkpoint and the stopwatches start
		 */
		public Duration sinceStart() {
<span class="nc" id="L248">			return Duration.between(getStopwatch().getStartInstant(), getInstant());</span>
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public Stopwatch getStopwatch() {
			return this.stopwatch;
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public String getName() {
			return this.name;
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public Instant getInstant() {
			return this.instant;
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public Optional&lt;Checkpoint&gt; getPreviousCheckpoint() {
			return this.previousCheckpoint;
		}

		@edu.umd.cs.findbugs.annotations.NonNull
		@java.lang.Override
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public java.lang.String toString() {
			return &quot;Stopwatch.Checkpoint(instant=&quot; + this.getInstant() + &quot;, name=&quot; + this.getName() + &quot;, previousCheckpoint=&quot; + this.getPreviousCheckpoint() + &quot;, stopwatch=&quot; + this.getStopwatch() + &quot;)&quot;;
		}

		@java.lang.Override
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public boolean equals(@edu.umd.cs.findbugs.annotations.Nullable final java.lang.Object o) {
			if (o == this) return true;
			if (!(o instanceof Stopwatch.Checkpoint)) return false;
			final Stopwatch.Checkpoint other = (Stopwatch.Checkpoint) o;
			if (!other.canEqual((java.lang.Object) this)) return false;
			final java.lang.Object this$name = this.getName();
			final java.lang.Object other$name = other.getName();
			if (this$name == null ? other$name != null : !this$name.equals(other$name)) return false;
			final java.lang.Object this$instant = this.getInstant();
			final java.lang.Object other$instant = other.getInstant();
			if (this$instant == null ? other$instant != null : !this$instant.equals(other$instant)) return false;
			final java.lang.Object this$previousCheckpoint = this.getPreviousCheckpoint();
			final java.lang.Object other$previousCheckpoint = other.getPreviousCheckpoint();
			if (this$previousCheckpoint == null ? other$previousCheckpoint != null : !this$previousCheckpoint.equals(other$previousCheckpoint)) return false;
			return true;
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		protected boolean canEqual(@edu.umd.cs.findbugs.annotations.Nullable final java.lang.Object other) {
			return other instanceof Stopwatch.Checkpoint;
		}

		@java.lang.Override
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public int hashCode() {
			final int PRIME = 59;
			int result = 1;
			final java.lang.Object $name = this.getName();
			result = result * PRIME + ($name == null ? 43 : $name.hashCode());
			final java.lang.Object $instant = this.getInstant();
			result = result * PRIME + ($instant == null ? 43 : $instant.hashCode());
			final java.lang.Object $previousCheckpoint = this.getPreviousCheckpoint();
			result = result * PRIME + ($previousCheckpoint == null ? 43 : $previousCheckpoint.hashCode());
			return result;
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		protected Checkpoint(final Stopwatch stopwatch, final String name, final Instant instant, final Optional&lt;Checkpoint&gt; previousCheckpoint) {
			this.stopwatch = stopwatch;
			this.name = name;
			this.instant = instant;
			this.previousCheckpoint = previousCheckpoint;
		}
	}

	/**
	 * Instant at the stopwatches start
	 *
	 * @return the instant at the stopwatches start time
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public Instant getStartInstant() {
		return this.startInstant;
	}

	@edu.umd.cs.findbugs.annotations.NonNull
	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public java.lang.String toString() {
		return &quot;Stopwatch(checkpoints=&quot; + this.getCheckpoints() + &quot;, startInstant=&quot; + this.getStartInstant() + &quot;)&quot;;
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public Stopwatch() {
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>