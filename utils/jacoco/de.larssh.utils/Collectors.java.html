<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Collectors.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Utilities</a> &gt; <a href="index.source.html" class="el_package">de.larssh.utils</a> &gt; <span class="el_source">Collectors.java</span></div><h1>Collectors.java</h1><pre class="source lang-java linenums">// Generated by delombok at Thu Jan 13 02:33:55 UTC 2022
package de.larssh.utils;

import static java.util.stream.Collectors.toCollection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;
import de.larssh.utils.text.Strings;

/**
 * This class contains helper methods for {@link Collector}.
 */
public final class Collectors {
	/**
	 * Returns a merge function, suitable for use in
	 * {@link java.util.Map#merge(Object, Object, java.util.function.BiFunction)
	 * Map.merge()} or
	 * {@link java.util.stream.Collectors#toMap(Function, Function, BinaryOperator)},
	 * which always throws {@link IllegalStateException}. This can be used to
	 * enforce the assumption that the elements being collected are distinct.
	 *
	 * @param &lt;T&gt; the type of input arguments to the merge function
	 * @return a merge function which always throw {@link IllegalStateException}
	 */
	public static &lt;T&gt; BinaryOperator&lt;T&gt; throwingMerger() {
<span class="fc" id="L33">		return (u, v) -&gt; {</span>
<span class="nc" id="L34">			throw new IllegalStateException(Strings.format(&quot;Duplicate key %s&quot;, u));</span>
		};
	}

	/**
	 * Returns a {@code Collector} that accumulates {@link Entry} elements into a
	 * {@code LinkedHashMap}.
	 *
	 * @param &lt;K&gt; the type of the key
	 * @param &lt;V&gt; the type of the value
	 * @return a {@code Collector} which collects {@link Entry} elements into a
	 *         {@code LinkedHashMap}
	 */
	public static &lt;K, V&gt; Collector&lt;Entry&lt;K, V&gt;, ?, Map&lt;K, V&gt;&gt; toLinkedHashMap() {
<span class="nc" id="L48">		return toLinkedHashMap(Entry::getKey, Entry::getValue, throwingMerger());</span>
	}

	/**
	 * Returns a {@code Collector} that accumulates elements into a
	 * {@code LinkedHashMap} whose keys and values are the result of applying the
	 * provided mapping functions to the input elements.
	 *
	 * @param &lt;T&gt;         the type of the input elements
	 * @param &lt;K&gt;         the output type of the key mapping function
	 * @param &lt;U&gt;         the output type of the value mapping function
	 * @param keyMapper   a mapping function to produce keys
	 * @param valueMapper a mapping function to produce values
	 * @return a {@code Collector} which collects elements into a
	 *         {@code LinkedHashMap} whose keys and values are the result of
	 *         applying mapping functions to the input elements
	 */
	public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K, U&gt;&gt; toLinkedHashMap(final Function&lt;? super T, ? extends K&gt; keyMapper, final Function&lt;? super T, ? extends U&gt; valueMapper) {
<span class="fc" id="L66">		return toLinkedHashMap(keyMapper, valueMapper, throwingMerger());</span>
	}

	/**
	 * Returns a {@code Collector} that accumulates elements into a
	 * {@code LinkedHashMap} whose keys and values are the result of applying the
	 * provided mapping functions to the input elements.
	 *
	 * @param &lt;T&gt;           the type of the input elements
	 * @param &lt;K&gt;           the output type of the key mapping function
	 * @param &lt;U&gt;           the output type of the value mapping function
	 * @param keyMapper     a mapping function to produce keys
	 * @param valueMapper   a mapping function to produce values
	 * @param mergeFunction a merge function, used to resolve collisions between
	 *                      values associated with the same key, as supplied to
	 *                      {@link java.util.Map#merge(Object, Object, java.util.function.BiFunction)}
	 * @return a {@code Collector} which collects elements into a
	 *         {@code LinkedHashMap} whose keys are the result of applying a key
	 *         mapping function to the input elements, and whose values are the
	 *         result of applying a value mapping function to all input elements
	 *         equal to the key and combining them using the merge function
	 */
	public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K, U&gt;&gt; toLinkedHashMap(final Function&lt;? super T, ? extends K&gt; keyMapper, final Function&lt;? super T, ? extends U&gt; valueMapper, final BinaryOperator&lt;U&gt; mergeFunction) {
<span class="fc" id="L89">		return toMap(keyMapper, valueMapper, mergeFunction, LinkedHashMap::new);</span>
	}

	/**
	 * Returns a {@link Collector} that accumulates the input elements into a new
	 * {@link LinkedHashSet}, in encounter order.
	 *
	 * @param &lt;T&gt; the type of the input elements
	 * @return a {@link Collector} which collects all the input elements into a
	 *         {@link LinkedHashSet}
	 */
	public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toLinkedHashSet() {
<span class="nc" id="L101">		return toCollection(LinkedHashSet::new);</span>
	}

	/**
	 * Returns a {@code Collector} that accumulates {@link Entry} elements into a
	 * {@code Map}.
	 *
	 * @param &lt;K&gt;         the type of the key
	 * @param &lt;V&gt;         the type of the value
	 * @param &lt;M&gt;         the type of the resulting {@code Map}
	 * @param mapSupplier a function which returns a new, empty {@code Map} into
	 *                    which the results will be inserted
	 * @return a {@code Collector} which collects {@link Entry} elements into a
	 *         {@code Map} created by {@code mapSupplier}
	 */
	public static &lt;K, V, M extends Map&lt;K, V&gt;&gt; Collector&lt;Entry&lt;K, V&gt;, ?, M&gt; toMap(final Supplier&lt;M&gt; mapSupplier) {
<span class="nc" id="L117">		return toMap(Entry::getKey, Entry::getValue, throwingMerger(), mapSupplier);</span>
	}

	/**
	 * Returns a {@code Collector} that accumulates elements into a {@code Map}
	 * whose keys and values are the result of applying the provided mapping
	 * functions to the input elements.
	 *
	 * &lt;p&gt;
	 * If the mapped keys contains duplicates (according to
	 * {@link Object#equals(Object)}), an {@code IllegalStateException} is thrown
	 * when the collection operation is performed. If the mapped keys may have
	 * duplicates, use {@link #toMap(Function, Function, BinaryOperator)} instead.
	 *
	 * @param &lt;T&gt;         the type of the input elements
	 * @param &lt;K&gt;         the output type of the key mapping function
	 * @param &lt;U&gt;         the output type of the value mapping function
	 * @param keyMapper   a mapping function to produce keys
	 * @param valueMapper a mapping function to produce values
	 * @return a {@code Collector} which collects elements into a {@code Map} whose
	 *         keys and values are the result of applying mapping functions to the
	 *         input elements
	 */
	public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K, U&gt;&gt; toMap(final Function&lt;? super T, ? extends K&gt; keyMapper, final Function&lt;? super T, ? extends U&gt; valueMapper) {
<span class="nc" id="L141">		return toMap(keyMapper, valueMapper, throwingMerger());</span>
	}

	/**
	 * Returns a {@code Collector} that accumulates elements into a {@code Map}
	 * whose keys and values are the result of applying the provided mapping
	 * functions to the input elements.
	 *
	 * &lt;p&gt;
	 * If the mapped keys contains duplicates (according to
	 * {@link Object#equals(Object)}), the value mapping function is applied to each
	 * equal element, and the results are merged using the provided merging
	 * function.
	 *
	 * @param &lt;T&gt;           the type of the input elements
	 * @param &lt;K&gt;           the output type of the key mapping function
	 * @param &lt;U&gt;           the output type of the value mapping function
	 * @param keyMapper     a mapping function to produce keys
	 * @param valueMapper   a mapping function to produce values
	 * @param mergeFunction a merge function, used to resolve collisions between
	 *                      values associated with the same key, as supplied to
	 *                      {@link java.util.Map#merge(Object, Object, java.util.function.BiFunction)}
	 * @return a {@code Collector} which collects elements into a {@code Map} whose
	 *         keys are the result of applying a key mapping function to the input
	 *         elements, and whose values are the result of applying a value mapping
	 *         function to all input elements equal to the key and combining them
	 *         using the merge function
	 */
	public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K, U&gt;&gt; toMap(final Function&lt;? super T, ? extends K&gt; keyMapper, final Function&lt;? super T, ? extends U&gt; valueMapper, final BinaryOperator&lt;U&gt; mergeFunction) {
<span class="nc" id="L170">		return toMap(keyMapper, valueMapper, mergeFunction, HashMap::new);</span>
	}

	/**
	 * Returns a {@code Collector} that accumulates elements into a {@code Map}
	 * whose keys and values are the result of applying the provided mapping
	 * functions to the input elements.
	 *
	 * &lt;p&gt;
	 * If the mapped keys contains duplicates (according to
	 * {@link Object#equals(Object)}), an {@code IllegalStateException} is thrown
	 * when the collection operation is performed. If the mapped keys may have
	 * duplicates, use {@link #toMap(Function, Function, BinaryOperator)} instead.
	 *
	 * @param &lt;T&gt;         the type of the input elements
	 * @param &lt;K&gt;         the output type of the key mapping function
	 * @param &lt;U&gt;         the output type of the value mapping function
	 * @param &lt;M&gt;         the type of the resulting {@code Map}
	 * @param keyMapper   a mapping function to produce keys
	 * @param valueMapper a mapping function to produce values
	 * @param mapSupplier a function which returns a new, empty {@code Map} into
	 *                    which the results will be inserted
	 * @return a {@code Collector} which collects elements into a {@code Map} whose
	 *         keys are the result of applying a key mapping function to the input
	 *         elements, and whose values are the result of applying a value mapping
	 *         function to all input elements equal to the key and combining them
	 *         using the merge function
	 */
	public static &lt;T, K, U, M extends Map&lt;K, U&gt;&gt; Collector&lt;T, ?, M&gt; toMap(final Function&lt;? super T, ? extends K&gt; keyMapper, final Function&lt;? super T, ? extends U&gt; valueMapper, final Supplier&lt;M&gt; mapSupplier) {
<span class="nc" id="L199">		return toMap(keyMapper, valueMapper, throwingMerger(), mapSupplier);</span>
	}

	/**
	 * Returns a {@code Collector} that accumulates elements into a {@code Map}
	 * whose keys and values are the result of applying the provided mapping
	 * functions to the input elements.
	 *
	 * &lt;p&gt;
	 * If the mapped keys contains duplicates (according to
	 * {@link Object#equals(Object)}), the value mapping function is applied to each
	 * equal element, and the results are merged using the provided merging
	 * function. The {@code Map} is created by a provided supplier function.
	 *
	 * @param &lt;T&gt;           the type of the input elements
	 * @param &lt;K&gt;           the output type of the key mapping function
	 * @param &lt;U&gt;           the output type of the value mapping function
	 * @param &lt;M&gt;           the type of the resulting {@code Map}
	 * @param keyMapper     a mapping function to produce keys
	 * @param valueMapper   a mapping function to produce values
	 * @param mergeFunction a merge function, used to resolve collisions between
	 *                      values associated with the same key, as supplied to
	 *                      {@link java.util.Map#merge(Object, Object, java.util.function.BiFunction)}
	 * @param mapSupplier   a function which returns a new, empty {@code Map} into
	 *                      which the results will be inserted
	 * @return a {@code Collector} which collects elements into a {@code Map} whose
	 *         keys are the result of applying a key mapping function to the input
	 *         elements, and whose values are the result of applying a value mapping
	 *         function to all input elements equal to the key and combining them
	 *         using the merge function
	 */
	public static &lt;T, K, U, M extends Map&lt;K, U&gt;&gt; Collector&lt;T, ?, M&gt; toMap(final Function&lt;? super T, ? extends K&gt; keyMapper, final Function&lt;? super T, ? extends U&gt; valueMapper, final BinaryOperator&lt;U&gt; mergeFunction, final Supplier&lt;M&gt; mapSupplier) {
<span class="fc" id="L231">		return java.util.stream.Collectors.toMap(keyMapper, valueMapper, mergeFunction, mapSupplier);</span>
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private Collectors() {
		throw new java.lang.UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>