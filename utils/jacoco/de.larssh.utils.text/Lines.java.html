<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Lines.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Utilities</a> &gt; <a href="index.source.html" class="el_package">de.larssh.utils.text</a> &gt; <span class="el_source">Lines.java</span></div><h1>Lines.java</h1><pre class="source lang-java linenums">// Generated by delombok at Sat Jun 20 10:10:57 UTC 2020
package de.larssh.utils.text;

import static com.google.common.collect.Iterators.peekingIterator;
import static java.util.stream.Collectors.toList;
import java.io.BufferedReader;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import com.google.common.collect.AbstractIterator;
import com.google.common.collect.PeekingIterator;
import de.larssh.utils.collection.Maps;
import edu.umd.cs.findbugs.annotations.Nullable;

/**
 * This class contains helper methods for line based processing.
 *
 * &lt;p&gt;
 * &lt;b&gt;Usage example 1:&lt;/b&gt; The following shows how to merge lines to logical log
 * lines.
 *
 * &lt;pre&gt;
 * // Some lines of example log files
 * final List&amp;lt;String&amp;gt; fileLines = lines(&quot;[20:57:30] Thread 0: Start request\n&quot;
 * 		+ &quot;[20:57:31] Thread 0: Request ID: Example 1\n&quot;
 * 		+ &quot;[20:57:31] Thread 0: Request failed: SomeException\n&quot;
 * 		+ &quot;  on line 12\n&quot;
 * 		+ &quot;  on line 34\n&quot;
 * 		+ &quot;[20:57:32] Thread 0: Stop request&quot;);
 *
 * // Calculating logical log lines based on consecutive lines
 * final Stream&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; logicalLogLines = consecutive(
 * 		fileLines,
 * 		(lines, line) -&amp;gt; !line.startsWith(&quot;[&quot;));
 *
 * // Output logical log lines with three dashes in between each of them
 * System.out.println(logicalLogLines //
 * 		.map(lines -&amp;gt; lines.stream().collect(joining(&quot;\n&quot;)))
 * 		.collect(joining(&quot;\n---\n&quot;)));
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Console output for usage example 1:
 *
 * &lt;pre&gt;
 * [20:57:30] Thread 1: Start request
 * ---
 * [20:57:31] Thread 1: Request ID: Example 1
 * ---
 * [20:57:31] Thread 1: Request failed: SomeException
 *   on line 12
 *   on line 34
 * ---
 * [20:57:32] Thread 1: Stop request
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * &lt;b&gt;Usage example 2:&lt;/b&gt; The following shows how to group log lines based on
 * their thread name.
 *
 * &lt;pre&gt;
 * // Some lines of example log files
 * final List&amp;lt;String&amp;gt; fileLines = lines(
 * 		  &quot;[20:57:30] Thread 1: Start request\n&quot;
 * 		+ &quot;[20:57:30] Thread 2: Stop request\n&quot;
 * 		+ &quot;[20:57:30] Thread 1: Request ID: Example 2.1\n&quot;
 * 		+ &quot;[20:57:31] Thread 2: Start request\n&quot;
 * 		+ &quot;[20:57:31] Thread 1: Request processed\n&quot;
 * 		+ &quot;[20:57:31] Thread 2: Request ID: Example 2.2\n&quot;
 * 		+ &quot;[20:57:32] Thread 1: Stop request\n&quot;
 * 		+ &quot;[20:57:32] Thread 2: Request processed&quot;);
 *
 * // Grouping log lines based on thread names
 * final Stream&amp;lt;Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;&amp;gt; groupedLogLines = grouped(
 * 		fileLines,
 * 		line -&amp;gt; line.substring(11, 19),
 * 		(lines, line) -&amp;gt; {
 * 			if (line.endsWith(&quot;Start request&quot;)) {
 * 				return GroupedLineType.START;
 * 			}
 * 			if (line.endsWith(&quot;Stop request&quot;)) {
 * 				return GroupedLineType.END;
 * 			}
 * 			return GroupedLineType.MIDDLE;
 * 		});
 *
 * // Output grouped lines with three dashes between each group
 * System.out.println(groupedLogLines
 * 		.map(entry -&amp;gt; entry.getKey() + &quot;:\n&quot; + entry.getValue().stream().collect(joining(&quot;\n&quot;)))
 * 		.collect(joining(&quot;\n---\n&quot;)));
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Console output for usage example 2:
 *
 * &lt;pre&gt;
 * Thread 2:
 * [20:57:30] Thread 2: Stop request
 * ---
 * Thread 1:
 * [20:57:30] Thread 1: Start request
 * [20:57:30] Thread 1: Request ID: Example 2.1
 * [20:57:31] Thread 1: Request processed
 * [20:57:32] Thread 1: Stop request
 * ---
 * Thread 2:
 * [20:57:31] Thread 2: Start request
 * [20:57:31] Thread 2: Request ID: Example 2.2
 * [20:57:32] Thread 2: Request processed
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Based on your your needs you might need to combine the methods
 * {@code lines(...)}, {@code consecutive(...)} and {@code grouped(...)}.
 */
public final class Lines {
	/**
	 * Creates lists of consecutive lines based on {@code lines}. An input line is
	 * added to an output list whenever {@code isNextConsecutive} returns
	 * {@code true}. On {@code false} a new list gets created.
	 *
	 * &lt;p&gt;
	 * Check out usage example 1 at {@link Lines}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Tip:&lt;/b&gt; {@code lines} must not necessarily consist of elements of type
	 * {@link String}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Note:&lt;/b&gt; This method requires {@code com.google.guava:guava} to be part
	 * of your dependencies!
	 *
	 * @param &lt;T&gt;               type of line (most probably {@link String})
	 * @param lines             the lines
	 * @param isNextConsecutive when returning {@code true} the input line is added
	 *                          to an output list, else a new list gets created. The
	 *                          first argument is the previous list of lines,
	 *                          whereas the second argument is the current line.
	 * @return stream of lists containing consecutive lines
	 */
	public static &lt;T&gt; Stream&lt;List&lt;T&gt;&gt; consecutive(final Iterable&lt;T&gt; lines, final BiPredicate&lt;List&lt;T&gt;, T&gt; isNextConsecutive) {
<span class="nc" id="L154">		return consecutive(StreamSupport.stream(lines.spliterator(), false), isNextConsecutive);</span>
	}

	/**
	 * Creates lists of consecutive lines based on {@code lines}. An input line is
	 * added to an output list whenever {@code isNextConsecutive} returns
	 * {@code true}. On {@code false} a new list gets created.
	 *
	 * &lt;p&gt;
	 * Check out usage example 1 at {@link Lines}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Tip:&lt;/b&gt; {@code lines} must not necessarily consist of elements of type
	 * {@link String}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Note:&lt;/b&gt; This method requires {@code com.google.guava:guava} to be part
	 * of your dependencies!
	 *
	 * @param &lt;T&gt;               type of line (most probably {@link String})
	 * @param lines             the lines
	 * @param isNextConsecutive when returning {@code true} the input line is added
	 *                          to an output list, else a new list gets created. The
	 *                          first argument is the previous list of lines,
	 *                          whereas the second argument is the current line.
	 * @return stream of lists containing consecutive lines
	 */
	@SuppressWarnings(&quot;checkstyle:IllegalToken&quot;)
	public static &lt;T&gt; Stream&lt;List&lt;T&gt;&gt; consecutive(final Iterator&lt;T&gt; lines, final BiPredicate&lt;List&lt;T&gt;, T&gt; isNextConsecutive) {
<span class="nc" id="L183">		final PeekingIterator&lt;T&gt; iterator = peekingIterator(lines);</span>
<span class="nc" id="L184">		return StreamSupport.stream(Spliterators.spliteratorUnknownSize(new AbstractIterator&lt;List&lt;T&gt;&gt;() {</span>
			/** {@inheritDoc} */
			@Nullable
			@Override
			protected List&lt;T&gt; computeNext() {
<span class="nc bnc" id="L189" title="All 2 branches missed.">				if (!iterator.hasNext()) {</span>
<span class="nc" id="L190">					return endOfData();</span>
				}
<span class="nc" id="L192">				final List&lt;T&gt; lines = new ArrayList&lt;&gt;();</span>
				do {
<span class="nc" id="L194">					lines.add(iterator.next());</span>
<span class="nc bnc" id="L195" title="All 4 branches missed.">				} while (iterator.hasNext() &amp;&amp; isNextConsecutive.test(lines, iterator.peek()));</span>
<span class="nc" id="L196">				return lines;</span>
			}
		}, Spliterator.NONNULL | Spliterator.ORDERED), false);
	}

	/**
	 * Creates lists of consecutive lines based on {@code lines}. An input line is
	 * added to an output list whenever {@code isNextConsecutive} returns
	 * {@code true}. On {@code false} a new list gets created.
	 *
	 * &lt;p&gt;
	 * Check out usage example 1 at {@link Lines}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Tip:&lt;/b&gt; {@code lines} must not necessarily consist of elements of type
	 * {@link String}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Note:&lt;/b&gt; This method requires {@code com.google.guava:guava} to be part
	 * of your dependencies!
	 *
	 * @param &lt;T&gt;               type of line (most probably {@link String})
	 * @param lines             the lines
	 * @param isNextConsecutive when returning {@code true} the input line is added
	 *                          to an output list, else a new list gets created. The
	 *                          first argument is the previous list of lines,
	 *                          whereas the second argument is the current line.
	 * @return stream of lists containing consecutive lines
	 */
	public static &lt;T&gt; Stream&lt;List&lt;T&gt;&gt; consecutive(final Stream&lt;T&gt; lines, final BiPredicate&lt;List&lt;T&gt;, T&gt; isNextConsecutive) {
<span class="nc" id="L226">		return consecutive(lines.iterator(), isNextConsecutive);</span>
	}

	/**
	 * Groups lines based on a key and line types. While {@code getGroupKey}
	 * calculates the key that is used for grouping {@code getLineType} calculates
	 * the line type, which specifies the way groups of lines are created and
	 * closed.
	 *
	 * &lt;p&gt;
	 * Check out usage example 2 at {@link Lines}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Tip:&lt;/b&gt; {@code lines} must not necessarily consist of elements of type
	 * {@link String}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Note:&lt;/b&gt; This method requires {@code com.google.guava:guava} to be part
	 * of your dependencies!
	 *
	 * @param &lt;K&gt;         type of the group key
	 * @param &lt;V&gt;         type of line
	 * @param lines       the lines
	 * @param getGroupKey calculates the lines group key
	 * @param getLineType calculates the lines type to specify the way groups of
	 *                    lines are created and closed. The first argument is the
	 *                    previous list of lines, whereas the second argument is the
	 *                    current line.
	 * @return stream of entries with the group key as key and the grouped lines as
	 *         value
	 */
	public static &lt;K, V&gt; Stream&lt;Entry&lt;K, List&lt;V&gt;&gt;&gt; grouped(final Iterable&lt;V&gt; lines, final Function&lt;V, K&gt; getGroupKey, final BiFunction&lt;List&lt;V&gt;, V, GroupedLineType&gt; getLineType) {
<span class="nc" id="L258">		return grouped(StreamSupport.stream(lines.spliterator(), false), getGroupKey, getLineType);</span>
	}

	/**
	 * Groups lines based on a key and line types. While {@code getGroupKey}
	 * calculates the key that is used for grouping {@code getLineType} calculates
	 * the line type, which specifies the way groups of lines are created and
	 * closed.
	 *
	 * &lt;p&gt;
	 * Check out usage example 2 at {@link Lines}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Tip:&lt;/b&gt; {@code lines} must not necessarily consist of elements of type
	 * {@link String}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Note:&lt;/b&gt; This method requires {@code com.google.guava:guava} to be part
	 * of your dependencies!
	 *
	 * @param &lt;K&gt;         type of the group key
	 * @param &lt;V&gt;         type of line
	 * @param lines       the lines
	 * @param getGroupKey calculates the lines group key
	 * @param getLineType calculates the lines type to specify the way groups of
	 *                    lines are created and closed. The first argument is the
	 *                    previous list of lines, whereas the second argument is the
	 *                    current line.
	 * @return stream of entries with the group key as key and the grouped lines as
	 *         value
	 */
	@SuppressWarnings({&quot;checkstyle:AnonInnerLength&quot;, &quot;checkstyle:IllegalToken&quot;})
	public static &lt;K, V&gt; Stream&lt;Entry&lt;K, List&lt;V&gt;&gt;&gt; grouped(final Iterator&lt;V&gt; lines, final Function&lt;V, K&gt; getGroupKey, final BiFunction&lt;List&lt;V&gt;, V, GroupedLineType&gt; getLineType) {
<span class="nc" id="L291">		return StreamSupport.stream(Spliterators.spliteratorUnknownSize(new AbstractIterator&lt;Entry&lt;K, List&lt;V&gt;&gt;&gt;() {</span>
			/**
			 * Buffer of not-closed groups of lines
			 */
<span class="nc" id="L295">			private final Map&lt;K, List&lt;V&gt;&gt; groups = new LinkedHashMap&lt;&gt;();</span>
			/** {@inheritDoc} */
			@Nullable
			@Override
			protected Entry&lt;K, List&lt;V&gt;&gt; computeNext() {
<span class="nc bnc" id="L300" title="All 2 branches missed.">				while (lines.hasNext()) {</span>
<span class="nc" id="L301">					final V line = lines.next();</span>
<span class="nc" id="L302">					final K groupKey = getGroupKey.apply(line);</span>
<span class="nc" id="L303">					List&lt;V&gt; groupOfCurrentLine = groups.computeIfAbsent(groupKey, key -&gt; new ArrayList&lt;&gt;());</span>
<span class="nc" id="L304">					final GroupedLineType lineType = getLineType.apply(groupOfCurrentLine, line);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">					if (lineType == GroupedLineType.END) {</span>
<span class="nc" id="L306">						groupOfCurrentLine.add(line);</span>
<span class="nc" id="L307">						return Maps.entry(groupKey, groups.remove(groupKey));</span>
					}
<span class="nc bnc" id="L309" title="All 4 branches missed.">					if (lineType == GroupedLineType.START &amp;&amp; !groupOfCurrentLine.isEmpty()) {</span>
<span class="nc" id="L310">						groupOfCurrentLine = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L311">						groupOfCurrentLine.add(line);</span>
<span class="nc" id="L312">						return Maps.entry(groupKey, groups.put(groupKey, groupOfCurrentLine));</span>
					}
<span class="nc" id="L314">					groupOfCurrentLine.add(line);</span>
<span class="nc" id="L315">				}</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">				if (groups.isEmpty()) {</span>
<span class="nc" id="L317">					return endOfData();</span>
				}
<span class="nc" id="L319">				final K groupKey = groups.keySet().iterator().next();</span>
<span class="nc" id="L320">				return Maps.entry(groupKey, groups.remove(groupKey));</span>
			}
		}, Spliterator.NONNULL | Spliterator.ORDERED), false);
	}

	/**
	 * Groups lines based on a key and line types. While {@code getGroupKey}
	 * calculates the key that is used for grouping {@code getLineType} calculates
	 * the line type, which specifies the way groups of lines are created and
	 * closed.
	 *
	 * &lt;p&gt;
	 * Check out usage example 2 at {@link Lines}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Tip:&lt;/b&gt; {@code lines} must not necessarily consist of elements of type
	 * {@link String}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Note:&lt;/b&gt; This method requires {@code com.google.guava:guava} to be part
	 * of your dependencies!
	 *
	 * @param &lt;K&gt;         type of the group key
	 * @param &lt;V&gt;         type of line
	 * @param lines       the lines
	 * @param getGroupKey calculates the lines group key
	 * @param getLineType calculates the lines type to specify the way groups of
	 *                    lines are created and closed. The first argument is the
	 *                    previous list of lines, whereas the second argument is the
	 *                    current line.
	 * @return stream of entries with the group key as key and the grouped lines as
	 *         value
	 */
	public static &lt;K, V&gt; Stream&lt;Entry&lt;K, List&lt;V&gt;&gt;&gt; grouped(final Stream&lt;V&gt; lines, final Function&lt;V, K&gt; getGroupKey, final BiFunction&lt;List&lt;V&gt;, V, GroupedLineType&gt; getLineType) {
<span class="nc" id="L354">		return grouped(lines.iterator(), getGroupKey, getLineType);</span>
	}

	/**
	 * Reads all characters of {@code reader} and splits them into lines using
	 * {@link BufferedReader#lines()}.
	 *
	 * @param reader character stream to split into lines
	 * @return list of lines
	 */
	public static Stream&lt;String&gt; lines(final Reader reader) {
<span class="nc bnc" id="L365" title="All 2 branches missed.">		final BufferedReader bufferedReader = reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);</span>
<span class="nc" id="L366">		return bufferedReader.lines();</span>
	}

	/**
	 * Splits {@code value} into lines using {@link BufferedReader#lines()}.
	 *
	 * @param value value to split
	 * @return list of lines
	 */
	public static List&lt;String&gt; lines(final String value) {
<span class="nc" id="L376">		return lines(new StringReader(value)).collect(toList());</span>
	}


	/**
	 * Specifies the way groups of lines are created and closed.
	 */
<span class="nc" id="L383">	@SuppressWarnings(&quot;PMD.UnnecessaryModifier&quot;)</span>
	public static enum GroupedLineType {
		/**
		 * Start of a group of lines
		 *
		 * &lt;p&gt;
		 * Creates a new group of lines. Closes a previously not-closed group, if any.
		 */
<span class="nc" id="L391">		START, </span>
		/**
		 * A grouped line, placed in a groups middle
		 *
		 * &lt;p&gt;
		 * Adds the current line to an existing group of lines. If no group was open, a
		 * new group is created.
		 */
<span class="nc" id="L399">		MIDDLE, </span>
		/**
		 * End of a group of lines
		 *
		 * &lt;p&gt;
		 * Closes an open group of lines, if any.
		 */
<span class="nc" id="L406">		END;</span>
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private Lines() {
		throw new java.lang.UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>