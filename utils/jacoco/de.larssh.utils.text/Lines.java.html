<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Lines.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Utilities</a> &gt; <a href="index.source.html" class="el_package">de.larssh.utils.text</a> &gt; <span class="el_source">Lines.java</span></div><h1>Lines.java</h1><pre class="source lang-java linenums">// Generated by delombok at Mon Mar 17 04:06:08 UTC 2025
package de.larssh.utils.text;

import static de.larssh.utils.collection.Iterators.peekableIterator;
import static java.util.stream.Collectors.toList;
import java.io.BufferedReader;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.stream.Stream;
import de.larssh.utils.collection.Iterators;
import de.larssh.utils.collection.Maps;
import de.larssh.utils.collection.PeekableIterator;

/**
 * This class contains helper methods for line based processing.
 *
 * &lt;p&gt;
 * &lt;b&gt;Usage example 1:&lt;/b&gt; The following shows how to merge lines to logical log
 * lines.
 *
 * &lt;pre&gt;
 * // Some lines of example log files
 * final List&amp;lt;String&amp;gt; fileLines = lines(&quot;[20:57:30] Thread 0: Start request\n&quot;
 * 		+ &quot;[20:57:31] Thread 0: Request ID: Example 1\n&quot;
 * 		+ &quot;[20:57:31] Thread 0: Request failed: SomeException\n&quot;
 * 		+ &quot;  on line 12\n&quot;
 * 		+ &quot;  on line 34\n&quot;
 * 		+ &quot;[20:57:32] Thread 0: Stop request&quot;);
 *
 * // Calculating logical log lines based on consecutive lines
 * final Stream&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; logicalLogLines = consecutive(
 * 		fileLines,
 * 		(lines, line) -&amp;gt; !line.startsWith(&quot;[&quot;));
 *
 * // Output logical log lines with three dashes in between each of them
 * System.out.println(logicalLogLines //
 * 		.map(lines -&amp;gt; lines.stream().collect(joining(&quot;\n&quot;)))
 * 		.collect(joining(&quot;\n---\n&quot;)));
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Console output for usage example 1:
 *
 * &lt;pre&gt;
 * [20:57:30] Thread 1: Start request
 * ---
 * [20:57:31] Thread 1: Request ID: Example 1
 * ---
 * [20:57:31] Thread 1: Request failed: SomeException
 *   on line 12
 *   on line 34
 * ---
 * [20:57:32] Thread 1: Stop request
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * &lt;b&gt;Usage example 2:&lt;/b&gt; The following shows how to group log lines based on
 * their thread name.
 *
 * &lt;pre&gt;
 * // Some lines of example log files
 * final List&amp;lt;String&amp;gt; fileLines = lines(
 * 		  &quot;[20:57:30] Thread 1: Start request\n&quot;
 * 		+ &quot;[20:57:30] Thread 2: Stop request\n&quot;
 * 		+ &quot;[20:57:30] Thread 1: Request ID: Example 2.1\n&quot;
 * 		+ &quot;[20:57:31] Thread 2: Start request\n&quot;
 * 		+ &quot;[20:57:31] Thread 1: Request processed\n&quot;
 * 		+ &quot;[20:57:31] Thread 2: Request ID: Example 2.2\n&quot;
 * 		+ &quot;[20:57:32] Thread 1: Stop request\n&quot;
 * 		+ &quot;[20:57:32] Thread 2: Request processed&quot;);
 *
 * // Grouping log lines based on thread names
 * final Stream&amp;lt;Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;&amp;gt; groupedLogLines = grouped(
 * 		fileLines,
 * 		line -&amp;gt; line.substring(11, 19),
 * 		(lines, line) -&amp;gt; {
 * 			if (line.endsWith(&quot;Start request&quot;)) {
 * 				return GroupedLineType.START;
 * 			}
 * 			if (line.endsWith(&quot;Stop request&quot;)) {
 * 				return GroupedLineType.END;
 * 			}
 * 			return GroupedLineType.MIDDLE;
 * 		});
 *
 * // Output grouped lines with three dashes between each group
 * System.out.println(groupedLogLines
 * 		.map(entry -&amp;gt; entry.getKey() + &quot;:\n&quot; + entry.getValue().stream().collect(joining(&quot;\n&quot;)))
 * 		.collect(joining(&quot;\n---\n&quot;)));
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Console output for usage example 2:
 *
 * &lt;pre&gt;
 * Thread 2:
 * [20:57:30] Thread 2: Stop request
 * ---
 * Thread 1:
 * [20:57:30] Thread 1: Start request
 * [20:57:30] Thread 1: Request ID: Example 2.1
 * [20:57:31] Thread 1: Request processed
 * [20:57:32] Thread 1: Stop request
 * ---
 * Thread 2:
 * [20:57:31] Thread 2: Start request
 * [20:57:31] Thread 2: Request ID: Example 2.2
 * [20:57:32] Thread 2: Request processed
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Based on your your needs you might need to combine the methods
 * {@code lines(...)}, {@code consecutive(...)} and {@code grouped(...)}. In
 * addition {@link de.larssh.utils.io.MultiReader} might be helpful to parse
 * data, which is spread over multiple files.
 */
public final class Lines {
	/**
	 * Creates lists of consecutive lines based on {@code lines}. An input line is
	 * added to an output list whenever {@code isNextConsecutive} returns
	 * {@code true}. On {@code false} a new list gets created.
	 *
	 * &lt;p&gt;
	 * Check out usage example 1 at {@link Lines}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Tip:&lt;/b&gt; {@code lines} must not necessarily consist of elements of type
	 * {@link String}.
	 *
	 * @param &lt;T&gt;               type of line (most probably {@link String})
	 * @param lines             the lines
	 * @param isNextConsecutive when returning {@code true} the input line is added
	 *                          to an output list, else a new list gets created. The
	 *                          first argument is the previous list of lines,
	 *                          whereas the second argument is the current line.
	 * @return stream of lists containing consecutive lines
	 */
	public static &lt;T&gt; Stream&lt;List&lt;T&gt;&gt; consecutive(final Iterable&lt;T&gt; lines, final BiPredicate&lt;List&lt;T&gt;, T&gt; isNextConsecutive) {
<span class="nc" id="L148">		return consecutive(lines.iterator(), isNextConsecutive);</span>
	}

	/**
	 * Creates lists of consecutive lines based on {@code lines}. An input line is
	 * added to an output list whenever {@code isNextConsecutive} returns
	 * {@code true}. On {@code false} a new list gets created.
	 *
	 * &lt;p&gt;
	 * Check out usage example 1 at {@link Lines}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Tip:&lt;/b&gt; {@code lines} must not necessarily consist of elements of type
	 * {@link String}.
	 *
	 * @param &lt;T&gt;               type of line (most probably {@link String})
	 * @param linesIterator     the lines
	 * @param isNextConsecutive when returning {@code true} the input line is added
	 *                          to an output list, else a new list gets created. The
	 *                          first argument is the previous list of lines,
	 *                          whereas the second argument is the current line.
	 * @return stream of lists containing consecutive lines
	 */
	public static &lt;T&gt; Stream&lt;List&lt;T&gt;&gt; consecutive(final Iterator&lt;T&gt; linesIterator, final BiPredicate&lt;List&lt;T&gt;, T&gt; isNextConsecutive) {
<span class="nc" id="L172">		final PeekableIterator&lt;T&gt; peekableLinesIterator = peekableIterator(linesIterator);</span>
<span class="nc" id="L173">		return Iterators.stream(state -&gt; {</span>
<span class="nc" id="L174">			final List&lt;T&gt; lines = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">			while (peekableLinesIterator.hasNext()) {</span>
<span class="nc" id="L176">				lines.add(peekableLinesIterator.next());</span>
				// Fail fast if the peeked line is not consecutive
<span class="nc bnc" id="L178" title="All 4 branches missed.">				if (peekableLinesIterator.hasNext() &amp;&amp; !isNextConsecutive.test(lines, peekableLinesIterator.peek())) {</span>
<span class="nc" id="L179">					return lines;</span>
				}
			}
<span class="nc bnc" id="L182" title="All 2 branches missed.">			return lines.isEmpty() ? state.endOfData() : lines;</span>
		});
	}

	/**
	 * Creates lists of consecutive lines based on {@code lines}. An input line is
	 * added to an output list whenever {@code isNextConsecutive} returns
	 * {@code true}. On {@code false} a new list gets created.
	 *
	 * &lt;p&gt;
	 * Check out usage example 1 at {@link Lines}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Tip:&lt;/b&gt; {@code lines} must not necessarily consist of elements of type
	 * {@link String}.
	 *
	 * @param &lt;T&gt;               type of line (most probably {@link String})
	 * @param lines             the lines
	 * @param isNextConsecutive when returning {@code true} the input line is added
	 *                          to an output list, else a new list gets created. The
	 *                          first argument is the previous list of lines,
	 *                          whereas the second argument is the current line.
	 * @return stream of lists containing consecutive lines
	 */
	public static &lt;T&gt; Stream&lt;List&lt;T&gt;&gt; consecutive(final Stream&lt;T&gt; lines, final BiPredicate&lt;List&lt;T&gt;, T&gt; isNextConsecutive) {
<span class="nc" id="L207">		return consecutive(lines.iterator(), isNextConsecutive);</span>
	}

	/**
	 * Groups lines based on a key and line types. While {@code getGroupKey}
	 * calculates the key that is used for grouping {@code getLineType} calculates
	 * the line type, which specifies the way groups of lines are created and
	 * closed.
	 *
	 * &lt;p&gt;
	 * Check out usage example 2 at {@link Lines}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Tip:&lt;/b&gt; {@code lines} must not necessarily consist of elements of type
	 * {@link String}.
	 *
	 * @param &lt;K&gt;         type of the group key
	 * @param &lt;V&gt;         type of line
	 * @param lines       the lines
	 * @param getGroupKey calculates the lines group key
	 * @param getLineType calculates the lines type to specify the way groups of
	 *                    lines are created and closed. The first argument is the
	 *                    previous list of lines, whereas the second argument is the
	 *                    current line.
	 * @return stream of entries with the group key as key and the grouped lines as
	 *         value
	 */
	public static &lt;K, V&gt; Stream&lt;Entry&lt;K, List&lt;V&gt;&gt;&gt; grouped(final Iterable&lt;V&gt; lines, final Function&lt;V, K&gt; getGroupKey, final BiFunction&lt;List&lt;V&gt;, V, GroupedLineType&gt; getLineType) {
<span class="nc" id="L235">		return grouped(lines.iterator(), getGroupKey, getLineType);</span>
	}

	/**
	 * Groups lines based on a key and line types. While {@code getGroupKey}
	 * calculates the key that is used for grouping {@code getLineType} calculates
	 * the line type, which specifies the way groups of lines are created and
	 * closed.
	 *
	 * &lt;p&gt;
	 * Check out usage example 2 at {@link Lines}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Tip:&lt;/b&gt; {@code lines} must not necessarily consist of elements of type
	 * {@link String}.
	 *
	 * @param &lt;K&gt;         type of the group key
	 * @param &lt;V&gt;         type of line
	 * @param lines       the lines
	 * @param getGroupKey calculates the lines group key
	 * @param getLineType calculates the lines type to specify the way groups of
	 *                    lines are created and closed. The first argument is the
	 *                    previous list of lines, whereas the second argument is the
	 *                    current line.
	 * @return stream of entries with the group key as key and the grouped lines as
	 *         value
	 */
	@SuppressWarnings(&quot;PMD.AvoidInstantiatingObjectsInLoops&quot;)
	public static &lt;K, V&gt; Stream&lt;Entry&lt;K, List&lt;V&gt;&gt;&gt; grouped(final Iterator&lt;V&gt; lines, final Function&lt;V, K&gt; getGroupKey, final BiFunction&lt;List&lt;V&gt;, V, GroupedLineType&gt; getLineType) {
		// Buffer of so-far not-closed groups of lines
<span class="nc" id="L265">		final Map&lt;K, List&lt;V&gt;&gt; groups = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L266">		return Iterators.stream(state -&gt; {</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">			while (lines.hasNext()) {</span>
<span class="nc" id="L268">				final V line = lines.next();</span>
<span class="nc" id="L269">				final K groupKey = getGroupKey.apply(line);</span>
<span class="nc" id="L270">				List&lt;V&gt; groupOfCurrentLine = groups.computeIfAbsent(groupKey, key -&gt; new ArrayList&lt;&gt;());</span>
<span class="nc" id="L271">				final GroupedLineType lineType = getLineType.apply(groupOfCurrentLine, line);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">				if (lineType == GroupedLineType.END) {</span>
<span class="nc" id="L273">					groupOfCurrentLine.add(line);</span>
<span class="nc" id="L274">					return Maps.entry(groupKey, groups.remove(groupKey));</span>
				}
<span class="nc bnc" id="L276" title="All 4 branches missed.">				if (lineType == GroupedLineType.START &amp;&amp; !groupOfCurrentLine.isEmpty()) {</span>
<span class="nc" id="L277">					groupOfCurrentLine = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L278">					groupOfCurrentLine.add(line);</span>
<span class="nc" id="L279">					return Maps.entry(groupKey, groups.put(groupKey, groupOfCurrentLine));</span>
				}
<span class="nc" id="L281">				groupOfCurrentLine.add(line);</span>
<span class="nc" id="L282">			}</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">			if (groups.isEmpty()) {</span>
<span class="nc" id="L284">				return state.endOfData();</span>
			}
<span class="nc" id="L286">			final K groupKey = groups.keySet().iterator().next();</span>
<span class="nc" id="L287">			return Maps.entry(groupKey, groups.remove(groupKey));</span>
		});
	}

	/**
	 * Groups lines based on a key and line types. While {@code getGroupKey}
	 * calculates the key that is used for grouping {@code getLineType} calculates
	 * the line type, which specifies the way groups of lines are created and
	 * closed.
	 *
	 * &lt;p&gt;
	 * Check out usage example 2 at {@link Lines}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Tip:&lt;/b&gt; {@code lines} must not necessarily consist of elements of type
	 * {@link String}.
	 *
	 * @param &lt;K&gt;         type of the group key
	 * @param &lt;V&gt;         type of line
	 * @param lines       the lines
	 * @param getGroupKey calculates the lines group key
	 * @param getLineType calculates the lines type to specify the way groups of
	 *                    lines are created and closed. The first argument is the
	 *                    previous list of lines, whereas the second argument is the
	 *                    current line.
	 * @return stream of entries with the group key as key and the grouped lines as
	 *         value
	 */
	public static &lt;K, V&gt; Stream&lt;Entry&lt;K, List&lt;V&gt;&gt;&gt; grouped(final Stream&lt;V&gt; lines, final Function&lt;V, K&gt; getGroupKey, final BiFunction&lt;List&lt;V&gt;, V, GroupedLineType&gt; getLineType) {
<span class="nc" id="L316">		return grouped(lines.iterator(), getGroupKey, getLineType);</span>
	}

	/**
	 * Reads all characters of {@code reader} and splits them into lines using
	 * {@link BufferedReader#lines()}.
	 *
	 * @param reader character stream to split into lines
	 * @return list of lines
	 */
	public static Stream&lt;String&gt; lines(final Reader reader) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">		final BufferedReader bufferedReader = reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);</span>
<span class="nc" id="L328">		return bufferedReader.lines();</span>
	}

	/**
	 * Splits {@code value} into lines using {@link BufferedReader#lines()}.
	 *
	 * @param value value to split
	 * @return list of lines
	 */
	public static List&lt;String&gt; lines(final String value) {
<span class="nc" id="L338">		return lines(new StringReader(value)).collect(toList());</span>
	}


	/**
	 * Specifies the way groups of lines are created and closed.
	 */
<span class="nc" id="L345">	@SuppressWarnings(&quot;PMD.UnnecessaryModifier&quot;)</span>
	public static enum GroupedLineType {
		/**
		 * Start of a group of lines
		 *
		 * &lt;p&gt;
		 * Creates a new group of lines. Closes a previously not-closed group, if any.
		 */
<span class="nc" id="L353">		START, /**</span>
		 * A grouped line, placed in a groups middle
		 *
		 * &lt;p&gt;
		 * Adds the current line to an existing group of lines. If no group was open, a
		 * new group is created.
		 */
<span class="nc" id="L360">		MIDDLE, /**</span>
		 * End of a group of lines
		 *
		 * &lt;p&gt;
		 * Closes an open group of lines, if any.
		 */
<span class="nc" id="L366">		END;</span>
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private Lines() {
		throw new java.lang.UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>