<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringConverters.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Utilities</a> &gt; <a href="index.source.html" class="el_package">de.larssh.utils.text</a> &gt; <span class="el_source">StringConverters.java</span></div><h1>StringConverters.java</h1><pre class="source lang-java linenums">// Generated by delombok at Thu May 13 00:17:02 UTC 2021
package de.larssh.utils.text;

import static java.util.stream.Collectors.joining;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.io.UncheckedIOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.Collection;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * This class contains helper methods for decoding and encoding strings.
 */
public final class StringConverters {
	/**
	 * Decodes {@code value} as Base64 string.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link Base64#getDecoder()} with the char
	 * set {@link Strings#DEFAULT_CHARSET}.
	 *
	 * @param value the value to be decoded
	 * @return the decoded value
	 */
	public static String decodeBase64(final String value) {
<span class="nc" id="L32">		return new String(Base64.getDecoder().decode(value), Strings.DEFAULT_CHARSET);</span>
	}

	/**
	 * Decodes {@code value} using the Base64 MIME type decoding scheme.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link Base64#getMimeDecoder()} with the
	 * char set {@link Strings#DEFAULT_CHARSET}.
	 *
	 * @param value the value to be decoded
	 * @return the decoded value
	 */
	public static String decodeBase64Mime(final String value) {
<span class="nc" id="L46">		return new String(Base64.getMimeDecoder().decode(value), Strings.DEFAULT_CHARSET);</span>
	}

	/**
	 * Decodes {@code value} as Base64 URL and filename-safe string.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link Base64#getUrlDecoder()} with the
	 * char set {@link Strings#DEFAULT_CHARSET}.
	 *
	 * @param value the value to be decoded
	 * @return the decoded value
	 */
	public static String decodeBase64Url(final String value) {
<span class="nc" id="L60">		return new String(Base64.getUrlDecoder().decode(value), Strings.DEFAULT_CHARSET);</span>
	}

	/**
	 * Parses the CSV data given by {@code data}.
	 *
	 * &lt;p&gt;
	 * To process {@link Reader} input, refer to
	 * {@link Csv#parse(Reader, char, char)}.
	 *
	 * @param data      the CSV input data
	 * @param separator the CSV separator character
	 * @param escaper   the CSV escaping character
	 * @return an object representing the parsed CSV data
	 * @throws IllegalArgumentException on illegal {@code separator} or
	 *                                  {@code escaper} value
	 */
	@SuppressFBWarnings(value = &quot;EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS&quot;, justification = &quot;converting checked to unchecked exception, that should never be thrown at all&quot;)
	public static Csv decodeCsv(final String data, final char separator, final char escaper) {
<span class="nc" id="L79">		try (Reader reader = new StringReader(data)) {</span>
<span class="nc" id="L80">			return Csv.parse(reader, separator, escaper);</span>
<span class="nc" id="L81">		} catch (final IOException e) {</span>
<span class="nc" id="L82">			throw new UncheckedIOException(e);</span>
		}
	}

	/**
	 * Decodes an {@code application/x-www-form-urlencoded} string.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link URLDecoder#decode(String)} with the
	 * char set {@link StandardCharsets#UTF_8} as the
	 * &lt;a href= &quot;https://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars&quot;&gt;
	 * World Wide Web Consortium Recommendation&lt;/a&gt; states that UTF-8 should be
	 * used.
	 *
	 * @param value the value to be decoded
	 * @return the decoded value
	 * @throws ParseException on illegal or incomplete hex characters
	 */
	@SuppressFBWarnings(value = &quot;EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS&quot;, justification = &quot;converting checked to unchecked exception, that should never be thrown at all&quot;)
	public static String decodeUrl(final String value) throws ParseException {
		try {
<span class="nc" id="L103">			return URLDecoder.decode(value, StandardCharsets.UTF_8.name());</span>
<span class="nc" id="L104">		} catch (final IllegalArgumentException e) {</span>
<span class="nc" id="L105">			throw new ParseException(e, &quot;Failed decoding URL.&quot;);</span>
<span class="nc" id="L106">		} catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L107">			throw new UncheckedIOException(e);</span>
		}
	}

	/**
	 * Translates {@code value} into Base64 format.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link Base64#getEncoder()} with the char
	 * set {@link Strings#DEFAULT_CHARSET}.
	 *
	 * @param value the value to be encoded
	 * @return the encoded value
	 */
	public static String encodeBase64(final String value) {
<span class="nc" id="L122">		return new String(Base64.getEncoder().encode(value.getBytes(Strings.DEFAULT_CHARSET)), Strings.DEFAULT_CHARSET);</span>
	}

	/**
	 * Translates {@code value} into Base64 MIME type encoding scheme.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link Base64#getMimeEncoder()} with the
	 * char set {@link Strings#DEFAULT_CHARSET}.
	 *
	 * @param value the value to be encoded
	 * @return the encoded value
	 */
	public static String encodeBase64Mime(final String value) {
<span class="nc" id="L136">		return new String(Base64.getMimeEncoder().encode(value.getBytes(Strings.DEFAULT_CHARSET)), Strings.DEFAULT_CHARSET);</span>
	}

	/**
	 * Translates {@code value} into Base64 URL and filename-safe format.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link Base64#getUrlEncoder()} with the
	 * charset {@link Strings#DEFAULT_CHARSET}.
	 *
	 * @param value the value to be encoded
	 * @return the encoded value
	 */
	public static String encodeBase64Url(final String value) {
<span class="nc" id="L150">		return new String(Base64.getUrlEncoder().encode(value.getBytes(Strings.DEFAULT_CHARSET)), Strings.DEFAULT_CHARSET);</span>
	}

	/**
	 * Encodes {@code data} as CSV document. Occurrences of special characters are
	 * encoded using {@code escaper} and values are separated using
	 * {@code separator}.
	 *
	 * &lt;p&gt;
	 * For more information on single value escaping see
	 * {@link #encodeCsvValue(String, char, char)}.
	 *
	 * @param data      the data to be encoded
	 * @param separator the CSV separator character
	 * @param escaper   the CSV escaping character
	 * @return the encoded CSV document
	 */
	public static String encodeCsv(final Collection&lt;? extends Collection&lt;String&gt;&gt; data, final char separator, final char escaper) {
<span class="nc" id="L168">		return  //</span>
<span class="nc" id="L169">		data.stream().map(row -&gt; encodeCsvRow(row, separator, escaper)).collect(joining(Strings.NEW_LINE));</span>
	}

	/**
	 * Encodes {@code values} as one CSV row. Occurrences of special characters are
	 * encoded using {@code escaper} and values are separated using
	 * {@code separator}.
	 *
	 * &lt;p&gt;
	 * For more information on single value escaping see
	 * {@link #encodeCsvValue(String, char, char)}.
	 *
	 * @param values    the values to be encoded
	 * @param separator the CSV separator character
	 * @param escaper   the CSV escaping character
	 * @return the encoded CSV row
	 */
	public static String encodeCsvRow(final Collection&lt;? extends String&gt; values, final char separator, final char escaper) {
<span class="nc" id="L187">		return values.stream().map(value -&gt; encodeCsvValue(value, separator, escaper)).collect(joining(Character.toString(separator)));</span>
	}

	/**
	 * Encodes {@code value} into a single CSV value. All occurrences of
	 * {@code escaper} are escaped (doubled). If {@code value} contains
	 * inappropriate characters, it is surrounded by {@code escaper}.
	 *
	 * &lt;p&gt;
	 * Inappropriate characters are {@code '\r'}, {@code '\n'}, {@code escaper} and
	 * {@code separator}. The latter is used for the list of inappropriate
	 * characters only.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Examples:&lt;/b&gt;
	 * &lt;table&gt;
	 * &lt;caption&gt;Examples&lt;/caption&gt;
	 * &lt;tr&gt;
	 * &lt;th&gt;Parameter&lt;/th&gt;
	 * &lt;th&gt;Return Value&lt;/th&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;EMPTY&lt;/td&gt;
	 * &lt;td&gt;EMPTY&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;abc&lt;/td&gt;
	 * &lt;td&gt;abc&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;abc&quot;xyz&lt;/td&gt;
	 * &lt;td&gt;&quot;abc&quot;&quot;xyz&quot;&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;&quot;&lt;/td&gt;
	 * &lt;td&gt;&quot;&quot;&quot;&quot;&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;/table&gt;
	 *
	 * @param value     the value to be encoded
	 * @param separator the CSV separator character
	 * @param escaper   the CSV escaping character
	 * @return the encoded value
	 */
	@SuppressWarnings(&quot;PMD.CyclomaticComplexity&quot;)
	public static String encodeCsvValue(final String value, final char separator, final char escaper) {
<span class="nc" id="L233">		CsvParser.assertCsvInput(separator, escaper);</span>
<span class="nc" id="L234">		final int length = value.length();</span>
<span class="nc" id="L235">		int index = 0;</span>
<span class="nc" id="L236">		boolean needsEscaping = false;</span>
<span class="nc bnc" id="L237" title="All 4 branches missed.">		for (; index &lt; length &amp;&amp; !needsEscaping; index += 1) {</span>
<span class="nc" id="L238">			final char character = value.charAt(index);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">			if (character == escaper) {</span>
<span class="nc" id="L240">				needsEscaping = true;</span>
<span class="nc" id="L241">				index -= 1;</span>
<span class="nc bnc" id="L242" title="All 6 branches missed.">			} else if (character == separator || character == '\r' || character == '\n') {</span>
<span class="nc" id="L243">				needsEscaping = true;</span>
			}
		}
<span class="nc bnc" id="L246" title="All 2 branches missed.">		if (!needsEscaping) {</span>
<span class="nc" id="L247">			return value;</span>
		}
<span class="nc" id="L249">		final StringBuilder builder = new StringBuilder(length + 2);</span>
<span class="nc" id="L250">		builder.append(escaper);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">		if (index &gt; 0) {</span>
<span class="nc" id="L252">			builder.append(value, 0, index);</span>
		}
<span class="nc bnc" id="L254" title="All 2 branches missed.">		for (; index &lt; length; index += 1) {</span>
<span class="nc" id="L255">			final char character = value.charAt(index);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">			if (character == escaper) {</span>
<span class="nc" id="L257">				builder.append(escaper);</span>
			}
<span class="nc" id="L259">			builder.append(character);</span>
		}
<span class="nc" id="L261">		return builder.append(escaper).toString();</span>
	}

	/**
	 * Translates a string into {@code application/x-www-form-urlencoded} format
	 * with the char set {@link StandardCharsets#UTF_8} as the
	 * &lt;a href= &quot;https://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars&quot;&gt;
	 * World Wide Web Consortium Recommendation&lt;/a&gt; states that UTF-8 should be
	 * used.
	 *
	 * @param value the value to be encoded
	 * @return the encoded value
	 */
	@SuppressFBWarnings(value = &quot;EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS&quot;, justification = &quot;converting checked to unchecked exception, that should never be thrown at all&quot;)
	public static String encodeUrl(final String value) {
		try {
<span class="nc" id="L277">			return URLEncoder.encode(value, StandardCharsets.UTF_8.name());</span>
<span class="nc" id="L278">		} catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L279">			throw new UncheckedIOException(e);</span>
		}
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private StringConverters() {
		throw new java.lang.UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>