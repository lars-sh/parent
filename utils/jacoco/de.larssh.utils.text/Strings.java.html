<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Strings.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Utilities</a> &gt; <a href="index.source.html" class="el_package">de.larssh.utils.text</a> &gt; <span class="el_source">Strings.java</span></div><h1>Strings.java</h1><pre class="source lang-java linenums">// Generated by delombok at Mon Jun 03 08:02:19 UTC 2024
package de.larssh.utils.text;

import static de.larssh.utils.Collectors.toLinkedHashMap;
import static de.larssh.utils.Finals.constant;
import static java.util.Arrays.asList;
import static java.util.Collections.unmodifiableMap;
import static java.util.stream.Collectors.joining;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Comparator;
import java.util.Formatter;
import java.util.IllegalFormatException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.IntStream;
import de.larssh.utils.Optionals;
import de.larssh.utils.collection.Maps;
import edu.umd.cs.findbugs.annotations.Nullable;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * This class contains helper methods for {@link String}.
 */
@SuppressWarnings({&quot;PMD.CyclomaticComplexity&quot;, &quot;PMD.ExcessiveImports&quot;, &quot;PMD.GodClass&quot;})
@SuppressFBWarnings(value = &quot;POTENTIAL_XML_INJECTION&quot;, justification = &quot;false positive caused by named groups&quot;)
public final class Strings {
	/**
	 * Character to separate strings inside regular expressions
	 */
	private static final String PATTERN_STRING_SEPARATOR = &quot;|&quot;;
	/**
	 * Map of binary units to their factor
	 *
	 * &lt;ul&gt;
	 * &lt;li&gt;{@code K}: {@code 1024}
	 * &lt;li&gt;{@code M}: {@code 1024 * 1024}
	 * &lt;li&gt;{@code G}: {@code 1024 * 1024 * 1024}
	 * &lt;li&gt;...
	 * &lt;/ul&gt;
	 */
<span class="fc" id="L50">	public static final Map&lt;String, BigDecimal&gt; BINARY_UNITS = unmodifiableMap(getBinaryUnits());</span>
	/**
	 * Pattern for parsing binary unit strings
	 */
<span class="fc" id="L54">	private static final Pattern BINARY_UNIT_PATTERN = Pattern.compile(&quot;(?i)^\\s*(?&lt;value&gt;[+-]?\\s*(\\d([\\d_]*\\d)?)?\\.?\\d([\\d_]*\\d)?)\\s*((?&lt;unit&gt;&quot; + BINARY_UNITS.keySet().stream().map(Pattern::quote).collect(joining(PATTERN_STRING_SEPARATOR)) + &quot;)i?)?\\s*$&quot;);</span>
	/**
	 * Map of decimal units to their power of ten
	 *
	 * &lt;ul&gt;
	 * &lt;li&gt;...
	 * &lt;li&gt;{@code m}: {@code -3}
	 * &lt;li&gt;{@code k}: {@code 3}
	 * &lt;li&gt;{@code M}: {@code 6}
	 * &lt;li&gt;...
	 * &lt;/ul&gt;
	 */
	@SuppressWarnings({&quot;checkstyle:MagicNumber&quot;, &quot;checkstyle:MultipleStringLiterals&quot;})
	@SuppressFBWarnings(value = &quot;PSC_PRESIZE_COLLECTIONS&quot;, justification = &quot;this method is called just once (in static initializer); keep code simple&quot;)
<span class="fc" id="L68">	public static final Map&lt;String, Integer&gt; DECIMAL_UNITS = Maps.&lt;String, Integer&gt;builder(new LinkedHashMap&lt;&gt;()).put(&quot;y&quot;, -24).put(&quot;z&quot;, -21).put(&quot;a&quot;, -18).put(&quot;f&quot;, -15).put(&quot;p&quot;, -12).put(&quot;n&quot;, -9).put(&quot;u&quot;, -6).put(&quot;Î¼&quot;, -6).put(&quot;m&quot;, -3).put(&quot;c&quot;, -2).put(&quot;d&quot;, -1).put(&quot;da&quot;, 1).put(&quot;h&quot;, 2).put(&quot;k&quot;, 3).put(&quot;M&quot;, 6).put(&quot;G&quot;, 9).put(&quot;T&quot;, 12).put(&quot;P&quot;, 15).put(&quot;E&quot;, 18).put(&quot;Z&quot;, 21).put(&quot;Y&quot;, 24).unmodifiable();</span>
	/**
	 * Pattern for parsing decimal unit strings
	 */
<span class="fc" id="L72">	private static final Pattern DECIMAL_UNIT_PATTERN = Pattern.compile(&quot;(?i)^\\s*(?&lt;value&gt;[+-]?\\s*(\\d([\\d_]*\\d)?)?\\.?\\d([\\d_]*\\d)?)\\s*(?&lt;unit&gt;&quot; + DECIMAL_UNITS.keySet().stream().map(Pattern::quote).collect(joining(PATTERN_STRING_SEPARATOR)) + &quot;)?\\s*$&quot;);</span>
	/**
	 * Constant UTF-8 for usage as default char set.
	 *
	 * &lt;p&gt;
	 * Using {@link java.nio.charset.Charset#defaultCharset()} leads to unexpected
	 * compatibility problems. While the new {@link java.nio.file.Files} API has
	 * been changed to use UTF-8 by default, old and third-party implementations
	 * still depend on the default char set or require a custom char set.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Why shouldn't I use {@link StandardCharsets#UTF_8} directly?&lt;/b&gt;&lt;br&gt;
	 * Using {@link StandardCharsets#UTF_8} is bad practice, as it holds
	 * implementation specific information.
	 */
<span class="fc" id="L87">	public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;</span>
	/**
	 * Constant locale as default locale where no language and country is required.
	 *
	 * &lt;p&gt;
	 * Using {@link Locale#getDefault()} leads to unexpected behavior for technical
	 * formatting operations. Therefore this locale specifies a default value.
	 *
	 * &lt;p&gt;
	 * The returned value is {@link Locale#ROOT}.
	 */
<span class="fc" id="L98">	public static final Locale DEFAULT_LOCALE = Locale.ROOT;</span>
	/**
	 * Constant {@code &quot;\n&quot;} &lt;b&gt;for output&lt;/b&gt;. Remember to accept {@code &quot;\r\n&quot;}
	 * and {@code &quot;\r&quot;} on the input side, too!
	 *
	 * &lt;p&gt;
	 * Using {@link System#lineSeparator()} leads to files, which cannot (should
	 * not) be transferred between UNIX and Microsoft Windows systems. To avoid
	 * problems, some developers decided to depend on the UNIX line separator only.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Why shouldn't I use {@code &quot;\n&quot;} directly?&lt;/b&gt;&lt;br&gt;
	 * Using {@code &quot;\n&quot;} is bad practice, as it holds implementation specific
	 * information.
	 */
<span class="fc" id="L113">	public static final String NEW_LINE = constant(&quot;\n&quot;);</span>
	/**
	 * Pattern to retrieve white space characters in binary and decimal unit strings
	 */
<span class="fc" id="L117">	private static final Pattern UNIT_WHITE_SPACE_PATTERN = Pattern.compile(&quot;[\\s_]+&quot;);</span>

	/**
	 * Compares two strings, ignoring case differences in the ASCII range.
	 *
	 * @param first  the first string to compare
	 * @param second the second string to compare
	 * @return a positive integer, zero, or a negative integer as {@code first} is
	 *         greater than, equal to, or less than {@code second}, ignoring case
	 *         considerations in the ASCII range.
	 */
	public static int compareIgnoreCaseAscii(final CharSequence first, final CharSequence second) {
<span class="nc" id="L129">		final int firstLength = first.length();</span>
<span class="nc" id="L130">		final int secondLength = second.length();</span>
<span class="nc" id="L131">		final int minLength = Math.min(firstLength, secondLength);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">		for (int index = 0; index &lt; minLength; index += 1) {</span>
<span class="nc" id="L133">			final int compare = Characters.compareIgnoreCaseAscii(first.charAt(index), second.charAt(index));</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">			if (compare != 0) {</span>
<span class="nc" id="L135">				return compare;</span>
			}
		}
<span class="nc bnc" id="L138" title="All 2 branches missed.">		if (firstLength == secondLength) {</span>
<span class="nc" id="L139">			return 0;</span>
		}
<span class="nc bnc" id="L141" title="All 2 branches missed.">		return firstLength &lt; secondLength ? -1 : 1;</span>
	}

	/**
	 * Tests if {@code value} contains {@code substring}, ignoring case
	 * considerations.
	 *
	 * @param string    the string to search in
	 * @param substring the sequence to search for
	 * @return {@code true} if {@code value} contains {@code substring}, ignoring
	 *         case considerations, else {@code false}
	 */
	public static boolean containsIgnoreCase(final CharSequence string, final CharSequence substring) {
<span class="nc bnc" id="L154" title="All 2 branches missed.">		return indexOfIgnoreCase(string, substring) != -1;</span>
	}

	/**
	 * Tests if {@code value} contains {@code substring}, ignoring case
	 * considerations in the ACII range.
	 *
	 * @param string    the string to search in
	 * @param substring the sequence to search for
	 * @return {@code true} if {@code value} contains {@code substring}, ignoring
	 *         case considerations in the ACII range, else {@code false}
	 */
	public static boolean containsIgnoreCaseAscii(final CharSequence string, final CharSequence substring) {
<span class="nc bnc" id="L167" title="All 2 branches missed.">		return indexOfIgnoreCaseAscii(string, substring) != -1;</span>
	}

	/**
	 * Compares {@code first} to {@code second}, ignoring case considerations in the
	 * ASCII range. Two strings are considered equal ignoring case if they are of
	 * the same length and corresponding characters in the two strings are equal
	 * ignoring case in the ASCII range.
	 *
	 * @param first  the first of both strings to compare
	 * @param second the second of both strings to compare
	 * @return {@code true} if {@code first} and {@code second} are considered
	 *         equal, ignoring case in the ACII range, else {@code false}
	 */
	@SuppressWarnings(&quot;PMD.CompareObjectsWithEquals&quot;)
	public static boolean equalsIgnoreCaseAscii(@Nullable final CharSequence first, @Nullable final CharSequence second) {
<span class="nc bnc" id="L183" title="All 4 branches missed.">		if (first == null || second == null) {</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">			return first == second;</span>
		}
<span class="nc bnc" id="L186" title="All 2 branches missed.">		return compareIgnoreCaseAscii(first, second) == 0;</span>
	}

	/**
	 * Tests if {@code value} ends with the specified suffix, ignoring case
	 * considerations.
	 *
	 * @param value  string to compare against
	 * @param suffix the suffix
	 * @return {@code true} if {@code prefix} is a suffix of the character sequence
	 *         represented by {@code value}, ignoring case considerations, else
	 *         {@code false}
	 */
	public static boolean endsWithIgnoreCase(final CharSequence value, final CharSequence suffix) {
<span class="nc" id="L200">		return startsWithIgnoreCase(value, suffix, value.length() - suffix.length());</span>
	}

	/**
	 * Tests if {@code value} ends with the specified suffix, ignoring case
	 * considerations in the ASCII range.
	 *
	 * @param value  string to compare against
	 * @param suffix the suffix
	 * @return {@code true} if {@code prefix} is a suffix of the character sequence
	 *         represented by {@code value}, ignoring case considerations in the
	 *         ASCII range, else {@code false}
	 */
	public static boolean endsWithIgnoreCaseAscii(final CharSequence value, final CharSequence suffix) {
<span class="nc" id="L214">		return startsWithIgnoreCaseAscii(value, suffix, value.length() - suffix.length());</span>
	}

	/**
	 * Tells whether or not a subsequence {@code input} matches {@code pattern}.
	 *
	 * &lt;p&gt;
	 * Use {@link Patterns#find(Pattern, CharSequence)} if you need a matcher.
	 *
	 * @param input   the input sequence to find the pattern in
	 * @param pattern the matching pattern
	 * @return {@code true} if, and only if, {@code input} matches {@code pattern}
	 */
	public static boolean find(final CharSequence input, final Pattern pattern) {
<span class="fc" id="L228">		return pattern.matcher(input).find();</span>
	}

	/**
	 * Returns a formatted string using the specified format string and
	 * {@code arguments}. In that way this method works &lt;i&gt;similar&lt;/i&gt; to
	 * {@link String#format(String, Object...)}.
	 *
	 * &lt;p&gt;
	 * Here are the differences:
	 * &lt;ul&gt;
	 * &lt;li&gt;In case {@code arguments} is empty, no checks and formatting is
	 * performed. {@code format} is returned immediately and without modification.
	 * &lt;li&gt;{@link #DEFAULT_LOCALE} is used instead of the systems default
	 * {@link Locale}.
	 * &lt;li&gt;On formatting failure no exception is thrown. When used for error
	 * messages this often hides the original error message. Instead a failure
	 * message is returned, containing {@code format}.
	 * &lt;/ul&gt;
	 *
	 * @param format    &lt;a href=&quot;../util/Formatter.html#syntax&quot;&gt;format string&lt;/a&gt;
	 * @param arguments arguments referenced by format specifiers in {@code format}
	 * @return formatted string
	 */
	@SuppressFBWarnings(value = &quot;FORMAT_STRING_MANIPULATION&quot;, justification = &quot;formatting exceptions are catched and handled accordingly&quot;)
	public static String format(final String format, final Object... arguments) {
<span class="nc bnc" id="L254" title="All 2 branches missed.">		if (arguments.length &lt; 1) {</span>
<span class="nc" id="L255">			return format;</span>
		}
<span class="nc" id="L257">		try (Formatter formatter = new Formatter(DEFAULT_LOCALE)) {</span>
<span class="nc" id="L258">			return formatter.format(format, arguments).toString();</span>
<span class="nc" id="L259">		} catch (final IllegalFormatException e) {</span>
<span class="nc" id="L260">			return &quot;Failed formatting string [&quot; + format + &quot;]: &quot; + e.getMessage();</span>
		}
	}

	/**
	 * Returns a map of binary units to their factor for static initialization.
	 *
	 * @return map map of binary units to their factor
	 */
	@SuppressWarnings(&quot;checkstyle:MultipleStringLiterals&quot;)
	private static Map&lt;String, BigDecimal&gt; getBinaryUnits() {
<span class="fc" id="L271">		final List&lt;String&gt; binaryUnits = asList(&quot;K&quot;, &quot;M&quot;, &quot;G&quot;, &quot;T&quot;, &quot;P&quot;, &quot;E&quot;, &quot;Z&quot;, &quot;Y&quot;);</span>
<span class="fc" id="L272">		final BigDecimal oneThousandTwentyFour = new BigDecimal(1024);</span>
<span class="fc" id="L273">		return IntStream.range(0, binaryUnits.size()).boxed().collect(toLinkedHashMap(binaryUnits::get, index -&gt; oneThousandTwentyFour.pow(index + 1)));</span>
	}

	/**
	 * Returns the index within {@code string} of the first occurrence of
	 * {@code substring}, ignoring e.g. case considerations using a custom character
	 * comparison method, starting at the specified index.
	 *
	 * @param string    the string to search in
	 * @param substring the substring to search for
	 * @param fromIndex the index from which to start the search
	 * @param equals    the character comparison method
	 * @return the index of the first occurrence of {@code substring}, starting at
	 *         the specified index, or {@code -1} if there is no such occurrence
	 */
	private static int indexOf(final CharSequence string, final CharSequence substring, final int fromIndex, final BiCharPredicate equals) {
<span class="nc" id="L289">		final int stringLength = string.length();</span>
		// Fix index
		int index;
<span class="nc bnc" id="L292" title="All 2 branches missed.">		if (fromIndex &lt; 0) {</span>
<span class="nc" id="L293">			index = 0;</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">		} else if (fromIndex &gt;= stringLength) {</span>
<span class="nc" id="L295">			index = stringLength;</span>
		} else {
<span class="nc" id="L297">			index = fromIndex;</span>
		}
		// Get first substring character
<span class="nc bnc" id="L300" title="All 2 branches missed.">		if (substring.length() == 0) {</span>
<span class="nc" id="L301">			return index;</span>
		}
<span class="nc" id="L303">		final char substringFirst = substring.charAt(0);</span>
		// Perform the search
<span class="nc" id="L305">		final int maxIndex = stringLength - substring.length();</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">		for (; index &lt;= maxIndex; index += 1) {</span>
<span class="nc bnc" id="L307" title="All 4 branches missed.">			if (equals.test(string.charAt(index), substringFirst) &amp;&amp; startsWith(string, substring, index, equals)) {</span>
<span class="nc" id="L308">				return index;</span>
			}
		}
<span class="nc" id="L311">		return -1;</span>
	}

	/**
	 * Returns the index within {@code string} of the first occurrence of
	 * {@code substring}, ignoring case considerations.
	 *
	 * @param string    the string to search in
	 * @param substring the substring to search for
	 * @return the index of the first occurrence of {@code substring}, ignoring case
	 *         considerations, or {@code -1} if there is no such occurrence
	 */
	public static int indexOfIgnoreCase(final CharSequence string, final CharSequence substring) {
<span class="nc" id="L324">		return indexOfIgnoreCase(string, substring, 0);</span>
	}

	/**
	 * Returns the index within {@code string} of the first occurrence of
	 * {@code substring}, ignoring case considerations, starting at the specified
	 * index.
	 *
	 * @param string    the string to search in
	 * @param substring the substring to search for
	 * @param fromIndex the index from which to start the search
	 * @return the index of the first occurrence of {@code substring}, ignoring case
	 *         considerations, starting at the specified index, or {@code -1} if
	 *         there is no such occurrence
	 */
	public static int indexOfIgnoreCase(final CharSequence string, final CharSequence substring, final int fromIndex) {
<span class="nc" id="L340">		return indexOf(string, substring, fromIndex, Characters::equalsIgnoreCase);</span>
	}

	/**
	 * Returns the index within {@code string} of the first occurrence of
	 * {@code substring}, ignoring case considerations in the ASCII range.
	 *
	 * @param string    the string to search in
	 * @param substring the substring to search for
	 * @return the index of the first occurrence of {@code substring}, ignoring case
	 *         considerations in the ASCII range, or {@code -1} if there is no such
	 *         occurrence
	 */
	public static int indexOfIgnoreCaseAscii(final CharSequence string, final CharSequence substring) {
<span class="nc" id="L354">		return indexOfIgnoreCaseAscii(string, substring, 0);</span>
	}

	/**
	 * Returns the index within {@code string} of the first occurrence of
	 * {@code substring}, ignoring case considerations in the ASCII range, starting
	 * at the specified index.
	 *
	 * @param string    the string to search in
	 * @param substring the substring to search for
	 * @param fromIndex the index from which to start the search
	 * @return the index of the first occurrence of {@code substring}, ignoring case
	 *         considerations in the ASCII range, starting at the specified index,
	 *         or {@code -1} if there is no such occurrence
	 */
	public static int indexOfIgnoreCaseAscii(final CharSequence string, final CharSequence substring, final int fromIndex) {
<span class="nc" id="L370">		return indexOf(string, substring, fromIndex, Characters::equalsIgnoreCaseAscii);</span>
	}

	/**
	 * Returns {@code true} if {@code value} consists of whitespace only or equals
	 * {@code null}.
	 *
	 * &lt;p&gt;
	 * This is an optimized way of {@code value.trim().isEmpty()}.
	 *
	 * @param value string
	 * @return {@code true} if {@code value} consists of whitespace only or equals
	 *         {@code null}
	 */
	public static boolean isBlank(@Nullable final CharSequence value) {
<span class="nc bnc" id="L385" title="All 2 branches missed.">		if (value == null) {</span>
<span class="nc" id="L386">			return true;</span>
		}
<span class="nc" id="L388">		final int length = value.length();</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">		for (int index = 0; index &lt; length; index += 1) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">			if (!Characters.isAsciiWhitespace(value.charAt(index))) {</span>
<span class="nc" id="L391">				return false;</span>
			}
		}
<span class="nc" id="L394">		return true;</span>
	}

	/**
	 * Tells whether or not {@code input} matches {@code pattern}.
	 *
	 * &lt;p&gt;
	 * Use {@link Patterns#matches(Pattern, CharSequence)} if you need a matcher.
	 *
	 * @param input   the value to match
	 * @param pattern the matching pattern
	 * @return {@code true} if, and only if, {@code input} matches {@code pattern}
	 */
	public static boolean matches(final CharSequence input, final Pattern pattern) {
<span class="fc" id="L408">		return pattern.matcher(input).matches();</span>
	}

	/**
	 * A {@link Comparator} that orders alpha numeric strings in &lt;i&gt;natural&lt;/i&gt;
	 * order, either case sensitive or case insensitive. It is appreciated to use
	 * this kind of ordering for user output.
	 *
	 * &lt;p&gt;
	 * Because numeric values are not deserialized into numeric data types, their
	 * length is not limited. Fractions are not supported and will be handled as two
	 * separate numeric values.
	 *
	 * &lt;p&gt;
	 * Numeric values can have a leading plus or minus sign when following a
	 * whitespace character or at a strings start.
	 *
	 * &lt;p&gt;
	 * The following lists some example values to demonstrate the ordering.
	 * &lt;ul&gt;
	 * &lt;li&gt;Banana -12 Circus
	 * &lt;li&gt;Banana -5 Circus
	 * &lt;li&gt;Banana +5 Circus
	 * &lt;li&gt;Banana 5 Circus
	 * &lt;li&gt;Banana +5 Dolphin
	 * &lt;li&gt;Banana 8 Circus
	 * &lt;li&gt;Banana 12 Circus
	 * &lt;li&gt;Banana-5 Circus
	 * &lt;li&gt;Banana-12 Circus
	 * &lt;li&gt;Banana--5 Circus
	 * &lt;li&gt;Elephant 5 Circus
	 * &lt;/ul&gt;
	 *
	 * &lt;p&gt;
	 * This comparator permits null values.
	 *
	 * &lt;p&gt;
	 * Note that this Comparator does &lt;em&gt;not&lt;/em&gt; take locale into account, and
	 * will result in an unsatisfactory ordering for certain locales.
	 *
	 * @param caseInsensitive {@code true} if comparison should take place case
	 *                        insensitive
	 * @return a {@link Comparator} that orders alpha numeric strings in
	 *         &lt;i&gt;natural&lt;/i&gt; order, either case sensitive or case insensitive. It
	 *         is appreciated to use this kind of ordering for user output.
	 */
	public static Comparator&lt;String&gt; numericTextComparator(final boolean caseInsensitive) {
<span class="nc bnc" id="L455" title="All 2 branches missed.">		return caseInsensitive ? NumericTextComparator.COMPARATOR_CASE_INSENSITIVE : NumericTextComparator.COMPARATOR_CASE_SENSITIVE;</span>
	}

	/**
	 * Parses {@code binaryValue} as binary value with
	 * &lt;ul&gt;
	 * &lt;li&gt;optional sign,
	 * &lt;li&gt;optional fraction
	 * &lt;li&gt;and optional binary unit (case insensitive matching).
	 * &lt;/ul&gt;
	 *
	 * &lt;p&gt;
	 * Binary units multiply by 1024. Though strings with fractions can be parsed,
	 * the resulting value must not contain a fraction part. Numeric values can be
	 * formatted using underscore, just as numeric Java literals can be formatted.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Examples:&lt;/b&gt;
	 * &lt;table&gt;
	 * &lt;caption&gt;Examples&lt;/caption&gt;
	 * &lt;tr&gt;
	 * &lt;th&gt;Parameter&lt;/th&gt;
	 * &lt;th&gt;Calculation&lt;/th&gt;
	 * &lt;th&gt;Return Value&lt;/th&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;-2m&lt;/td&gt;
	 * &lt;td&gt;-2 * 1024 * 1024&lt;/td&gt;
	 * &lt;td&gt;-2 097 152&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;0&lt;/td&gt;
	 * &lt;td&gt;&lt;/td&gt;
	 * &lt;td&gt;0&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;5.4k&lt;/td&gt;
	 * &lt;td&gt;5.4 * 1024&lt;/td&gt;
	 * &lt;td&gt;5529.6 -&amp;gt; ArithmeticException&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;+5_432&lt;/td&gt;
	 * &lt;td&gt;&lt;/td&gt;
	 * &lt;td&gt;5 432&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;/table&gt;
	 *
	 * @param binaryValue binary string
	 * @return binary value
	 * @throws StringParseException on parse failure
	 */
	@SuppressWarnings(&quot;checkstyle:MultipleStringLiterals&quot;)
	public static BigInteger parseBinaryUnit(final CharSequence binaryValue) throws StringParseException {
<span class="nc" id="L508">		final Optional&lt;Matcher&gt; matcher = Patterns.matches(BINARY_UNIT_PATTERN, binaryValue);</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">		if (!matcher.isPresent()) {</span>
<span class="nc" id="L510">			throw new StringParseException(&quot;Value [%s] does not match binary unit pattern.&quot;, binaryValue);</span>
		}
<span class="nc" id="L512">		final String value = matcher.get().group(&quot;value&quot;);</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">		if (value == null) {</span>
<span class="nc" id="L514">			throw new StringParseException(&quot;No binary unit value given in string [%s].&quot;, binaryValue);</span>
		}
<span class="nc" id="L516">		final String unit = matcher.get().group(&quot;unit&quot;);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">		final BigDecimal multiplicator = unit == null ? BigDecimal.ONE : BINARY_UNITS.get(toUpperCaseAscii(unit));</span>
<span class="nc" id="L518">		return new BigDecimal(replaceAll(value, UNIT_WHITE_SPACE_PATTERN, &quot;&quot;)).multiply(multiplicator).toBigIntegerExact();</span>
	}

	/**
	 * Parses {@code decimalValue} as decimal value with
	 * &lt;ul&gt;
	 * &lt;li&gt;optional sign,
	 * &lt;li&gt;optional fraction
	 * &lt;li&gt;and optional decimal unit (case insensitive matching - where possible).
	 * &lt;/ul&gt;
	 *
	 * &lt;p&gt;
	 * Numeric values can be formatted using underscore, just as numeric Java
	 * literals can be formatted.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Examples:&lt;/b&gt;
	 * &lt;table&gt;
	 * &lt;caption&gt;Examples&lt;/caption&gt;
	 * &lt;tr&gt;
	 * &lt;th&gt;Parameter&lt;/th&gt;
	 * &lt;th&gt;Return Value&lt;/th&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;-2m&lt;/td&gt;
	 * &lt;td&gt;-0.002&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;0&lt;/td&gt;
	 * &lt;td&gt;0&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;5.4k&lt;/td&gt;
	 * &lt;td&gt;5 400&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;+5_432&lt;/td&gt;
	 * &lt;td&gt;5 432&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;/table&gt;
	 *
	 * @param decimalValue decimal string
	 * @return decimal value
	 * @throws StringParseException on parse failure
	 */
	@SuppressWarnings(&quot;checkstyle:MultipleStringLiterals&quot;)
	public static BigDecimal parseDecimalUnit(final CharSequence decimalValue) throws StringParseException {
<span class="nc" id="L565">		final Optional&lt;Matcher&gt; matcher = Patterns.matches(DECIMAL_UNIT_PATTERN, decimalValue);</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">		if (!matcher.isPresent()) {</span>
<span class="nc" id="L567">			throw new StringParseException(&quot;Value [%s] does not match decimal unit pattern.&quot;, decimalValue);</span>
		}
<span class="nc" id="L569">		final String value = matcher.get().group(&quot;value&quot;);</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">		if (value == null) {</span>
<span class="nc" id="L571">			throw new StringParseException(&quot;No decimal unit value given in string [%s].&quot;, decimalValue);</span>
		}
<span class="nc" id="L573">		final String unit = matcher.get().group(&quot;unit&quot;);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">		final int powerOfTen = Optionals.getFirst(Objects::nonNull, () -&gt; unit == null ? 0 : null, () -&gt; DECIMAL_UNITS.get(unit), () -&gt; DECIMAL_UNITS.get(toUpperCaseAscii(unit)), () -&gt; DECIMAL_UNITS.get(toLowerCaseAscii(unit))).orElseThrow(() -&gt; new StringParseException(&quot;Found unexpected decimal unit [%s].&quot;, unit));</span>
<span class="nc" id="L575">		return new BigDecimal(replaceAll(value, UNIT_WHITE_SPACE_PATTERN, &quot;&quot;)).scaleByPowerOfTen(powerOfTen);</span>
	}

	/**
	 * Replaces the first subsequence of {@code input} that matches {@code pattern}
	 * with {@code replacement}.
	 *
	 * &lt;p&gt;
	 * Note that {@code replacement} is not a literal replacement string.
	 * Backslashes ({@code \}) and dollar signs ({@code $}) may be treated
	 * differently. Quote unknown literal replacement strings using
	 * {@link Matcher#quoteReplacement(String)}.
	 *
	 * @param input       the value to match
	 * @param pattern     the matching pattern
	 * @param replacement the replacement string
	 * @return the string constructed by replacing each matching subsequence by the
	 *         replacement string, substituting captured subsequences as needed
	 */
	public static String replaceFirst(final CharSequence input, final Pattern pattern, final String replacement) {
<span class="nc" id="L595">		return pattern.matcher(input).replaceFirst(replacement);</span>
	}

	/**
	 * Replaces every subsequence of {@code input} that matches {@code pattern} with
	 * {@code replacement}.
	 *
	 * &lt;p&gt;
	 * Note that {@code replacement} is not a literal replacement string.
	 * Backslashes ({@code \}) and dollar signs ({@code $}) may be treated
	 * differently. Quote unknown literal replacement strings using
	 * {@link Matcher#quoteReplacement(String)}.
	 *
	 * @param input       the value to match
	 * @param pattern     the matching pattern
	 * @param replacement the replacement string
	 * @return the string constructed by replacing each matching subsequence by the
	 *         replacement string, substituting captured subsequences as needed
	 */
	public static String replaceAll(final CharSequence input, final Pattern pattern, final String replacement) {
<span class="fc" id="L615">		return pattern.matcher(input).replaceAll(replacement);</span>
	}

	/**
	 * Tests if the substring of {@code value} beginning at {@code offset} starts
	 * with {@code prefix}, ignoring e.g. case considerations using a custom
	 * character comparison method.
	 *
	 * @param value  string to compare against
	 * @param prefix the prefix
	 * @param offset where to begin looking in {@code value}
	 * @param equals the character comparison method
	 * @return {@code true} if {@code prefix} is a prefix of the substring of
	 *         {@code value} starting at {@code offset}, else {@code false}. The
	 *         result is {@code false} if {@code offset} is negative or greater than
	 *         the length of {@code value}.
	 */
	private static boolean startsWith(final CharSequence value, final CharSequence prefix, final int offset, final BiCharPredicate equals) {
<span class="nc" id="L633">		final int prefixLength = prefix.length();</span>
<span class="nc bnc" id="L634" title="All 4 branches missed.">		if (offset &lt; 0 || offset + prefixLength &gt; value.length()) {</span>
<span class="nc" id="L635">			return false;</span>
		}
<span class="nc bnc" id="L637" title="All 2 branches missed.">		for (int index = 0; index &lt; prefixLength; index += 1) {</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">			if (!equals.test(value.charAt(offset + index), prefix.charAt(index))) {</span>
<span class="nc" id="L639">				return false;</span>
			}
		}
<span class="nc" id="L642">		return true;</span>
	}

	/**
	 * Tests if {@code value} starts with {@code prefix} ignoring case
	 * considerations.
	 *
	 * @param value  string to compare against
	 * @param prefix the prefix
	 * @return {@code true} if {@code prefix} is a prefix of {@code value}, ignoring
	 *         case considerations, else {@code false}
	 */
	public static boolean startsWithIgnoreCase(final CharSequence value, final CharSequence prefix) {
<span class="nc" id="L655">		return startsWithIgnoreCase(value, prefix, 0);</span>
	}

	/**
	 * Tests if the substring of {@code value} beginning at {@code offset} starts
	 * with {@code prefix}, ignoring case considerations.
	 *
	 * @param value  string to compare against
	 * @param prefix the prefix
	 * @param offset where to begin looking in {@code value}
	 * @return {@code true} if {@code prefix} is a prefix of the substring of
	 *         {@code value} starting at {@code offset}, ignoring case
	 *         considerations, else {@code false}. The result is {@code false} if
	 *         {@code offset} is negative or greater than the length of
	 *         {@code value}.
	 */
	public static boolean startsWithIgnoreCase(final CharSequence value, final CharSequence prefix, final int offset) {
<span class="nc" id="L672">		return startsWith(value, prefix, offset, Characters::equalsIgnoreCase);</span>
	}

	/**
	 * Tests if {@code value} starts with the specified prefix, ignoring case
	 * considerations in the ASCII range.
	 *
	 * @param value  string to compare against
	 * @param prefix the prefix
	 * @return {@code true} if {@code prefix} is a prefix of the character sequence
	 *         represented by {@code value}, ignoring case considerations in the
	 *         ASCII range, else {@code false}
	 */
	public static boolean startsWithIgnoreCaseAscii(final CharSequence value, final CharSequence prefix) {
<span class="nc" id="L686">		return startsWithIgnoreCaseAscii(value, prefix, 0);</span>
	}

	/**
	 * Tests if the substring of {@code value} beginning at the specified index
	 * starts with the specified prefix, ignoring case considerations in the ASCII
	 * range.
	 *
	 * @param value  string to compare against
	 * @param prefix the prefix
	 * @param offset where to begin looking in {@code value}.
	 * @return {@code true} if {@code prefix} is a prefix of the substring of
	 *         {@code value} starting at index {@code offset}, ignoring case
	 *         considerations in the ASCII range, else {@code false}. The result is
	 *         {@code false} if {@code offset} is negative or greater than the
	 *         length of this {@code String} object.
	 */
	public static boolean startsWithIgnoreCaseAscii(final CharSequence value, final CharSequence prefix, final int offset) {
<span class="nc" id="L704">		return startsWith(value, prefix, offset, Characters::equalsIgnoreCaseAscii);</span>
	}

	/**
	 * Converts all of the ASCII upper case characters in {@code value} to lower
	 * case.
	 *
	 * @param value string to convert
	 * @return converted string
	 */
	public static String toLowerCaseAscii(final CharSequence value) {
<span class="nc" id="L715">		final int length = value.length();</span>
<span class="nc" id="L716">		final StringBuilder builder = new StringBuilder(length);</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">		for (int index = 0; index &lt; length; index += 1) {</span>
<span class="nc" id="L718">			builder.append(Characters.toLowerCaseAscii(value.charAt(index)));</span>
		}
<span class="nc" id="L720">		return builder.toString();</span>
	}

	/**
	 * Converts all of the characters in {@code value} to lower case using
	 * {@link #DEFAULT_LOCALE}. This method is equivalent to
	 * {@code toLowerCase(Locale.ROOT)}.
	 *
	 * @param value string to convert
	 * @return converted string
	 */
	public static String toLowerCaseNeutral(final String value) {
<span class="nc" id="L732">		return value.toLowerCase(DEFAULT_LOCALE);</span>
	}

	/**
	 * Converts {@code value} to title case by converting its first character using
	 * {@link Character#toTitleCase(char)} and following to lower case using
	 * {@link #DEFAULT_LOCALE}.
	 *
	 * @param value string to convert
	 * @return converted string
	 */
	public static String toTitleCaseNeutral(final String value) {
<span class="nc bnc" id="L744" title="All 2 branches missed.">		if (value.isEmpty()) {</span>
<span class="nc" id="L745">			return value;</span>
		}
<span class="nc" id="L747">		final int length = value.length();</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">		if (length == 1) {</span>
<span class="nc" id="L749">			return Character.toString(Character.toTitleCase(value.charAt(0)));</span>
		}
<span class="nc" id="L751">		final String lowerCase = value.toLowerCase(DEFAULT_LOCALE);</span>
<span class="nc" id="L752">		return new StringBuilder(length).append(Character.toTitleCase(value.charAt(0))).append(lowerCase, 1, lowerCase.length()).toString();</span>
	}

	/**
	 * Converts all of the ASCII lower case characters in {@code value} to upper
	 * case.
	 *
	 * @param value string to convert
	 * @return converted string
	 */
	public static String toUpperCaseAscii(final CharSequence value) {
<span class="nc" id="L763">		final int length = value.length();</span>
<span class="nc" id="L764">		final StringBuilder builder = new StringBuilder(length);</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">		for (int index = 0; index &lt; length; index += 1) {</span>
<span class="nc" id="L766">			builder.append(Characters.toUpperCaseAscii(value.charAt(index)));</span>
		}
<span class="nc" id="L768">		return builder.toString();</span>
	}

	/**
	 * Converts all of the characters in {@code value} to upper case using
	 * {@link #DEFAULT_LOCALE}. This method is equivalent to
	 * {@code toUpperCase(Locale.ROOT)}.
	 *
	 * @param value string to convert
	 * @return converted string
	 */
	public static String toUpperCaseNeutral(final String value) {
<span class="nc" id="L780">		return value.toUpperCase(DEFAULT_LOCALE);</span>
	}

	/**
	 * Returns a string similar to {@code value}, but with any leading whitespace
	 * removed.
	 *
	 * &lt;p&gt;
	 * This method works similar to {@link String#trim()}, though it handles only
	 * the strings start.
	 *
	 * &lt;p&gt;
	 * Whitespace characters are recognized using
	 * {@link Characters#isAsciiWhitespace(char)}.
	 *
	 * @param value value
	 * @return left trimmed value
	 */
	public static String trimStart(final CharSequence value) {
<span class="nc" id="L799">		final int length = value.length();</span>
<span class="nc" id="L800">		int start = 0;</span>
<span class="nc bnc" id="L801" title="All 4 branches missed.">		while (start &lt; length &amp;&amp; Characters.isAsciiWhitespace(value.charAt(start))) {</span>
<span class="nc" id="L802">			start += 1;</span>
		}
<span class="nc" id="L804">		return value.subSequence(start, length).toString();</span>
	}

	/**
	 * Returns a string similar to {@code value}, but with any trailing whitespace
	 * removed.
	 *
	 * &lt;p&gt;
	 * This method works similar to {@link String#trim()}, though it handles only
	 * the strings end.
	 *
	 * &lt;p&gt;
	 * Whitespace characters are recognized using
	 * {@link Characters#isAsciiWhitespace(char)}.
	 *
	 * @param value value
	 * @return left trimmed value
	 */
	public static String trimEnd(final CharSequence value) {
<span class="nc" id="L823">		int end = value.length();</span>
<span class="nc bnc" id="L824" title="All 4 branches missed.">		while (end &gt; 0 &amp;&amp; Characters.isAsciiWhitespace(value.charAt(end - 1))) {</span>
<span class="nc" id="L825">			end -= 1;</span>
		}
<span class="nc" id="L827">		return value.subSequence(0, end).toString();</span>
	}


	/**
	 * Represents a predicate (boolean-valued function) of two primitive
	 * {@code char} arguments.
	 *
	 * &lt;p&gt;
	 * This is a functional interface whose functional method is
	 * {@link #test(char, char)}.
	 */
	@FunctionalInterface
	@SuppressWarnings(&quot;PMD.UnnecessaryModifier&quot;)
	private static interface BiCharPredicate {
		/**
		 * Evaluates this predicate on the given arguments.
		 *
		 * @param first  the first input argument
		 * @param second the second input argument
		 * @return {@code true} if the input arguments match the predicate, otherwise
		 *         {@code false}
		 */
		boolean test(char first, char second);
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private Strings() {
		throw new java.lang.UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>