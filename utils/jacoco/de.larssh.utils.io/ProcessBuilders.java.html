<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProcessBuilders.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Utilities</a> &gt; <a href="index.source.html" class="el_package">de.larssh.utils.io</a> &gt; <span class="el_source">ProcessBuilders.java</span></div><h1>ProcessBuilders.java</h1><pre class="source lang-java linenums">// Generated by delombok at Fri Mar 31 08:15:54 UTC 2023
package de.larssh.utils.io;

import static java.util.stream.Collectors.joining;
import java.io.File;
import java.lang.ProcessBuilder.Redirect;
import java.lang.ProcessBuilder.Redirect.Type;
import java.nio.file.Paths;
import java.util.function.UnaryOperator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import de.larssh.utils.Nullables;
import de.larssh.utils.SystemUtils;
import de.larssh.utils.annotations.PackagePrivate;
import de.larssh.utils.text.Strings;

/**
 * This class contains helper methods for {@link ProcessBuilder}.
 */
public final class ProcessBuilders {
	/**
	 * Pattern describing all single characters retaining the special meaning of a
	 * backslash when the backslash is followed by this characters inside a Unix
	 * command line arguments.
	 */
<span class="fc" id="L26">	private static final Pattern UNIX_BACKSLASH_SPECIAL_MEANING_CHARACTER_PATTERN = Pattern.compile(&quot;[\r\n!\&quot;$\\\\`]&quot;);</span>
	/**
	 * Pattern describing Unix command line arguments, which can be safely used
	 * without quoting and escaping.
	 */
<span class="fc" id="L31">	private static final Pattern UNIX_SAFE_ARGUMENT_PATTERN = Pattern.compile(&quot;[-.0-9A-Z_a-z]+&quot;);</span>
	/**
	 * Pattern describing a single double quote
	 */
<span class="fc" id="L35">	private static final Pattern WINDOWS_DOUBLE_QUOTE_PATTERN = Pattern.compile(&quot;\&quot;&quot;);</span>
	/**
	 * Pattern describing all single space characters inside Windows command line
	 * arguments, requiring an argument to be escaped.
	 */
<span class="fc" id="L40">	private static final Pattern WINDOWS_SPACE_CHARACTER_PATTERN = Pattern.compile(&quot;[ \t\n\013]&quot;);</span>

	/**
	 * Appends the redirect {@code operation} to {@code file} to {@code builder}.
	 * {@code file} is converted into an absolute path and normalized.
	 *
	 * @param builder   the builder to append to
	 * @param operation the redirect operation
	 * @param file      the path of the redirection
	 */
	private static void appendRedirect(final StringBuilder builder, final String operation, final File file) {
<span class="fc" id="L51">		final String normalizedPath = file.toPath().toAbsolutePath().normalize().toString();</span>
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">		builder.append(' ').append(operation).append(' ').append(SystemUtils.isWindows() ? escapeArgumentOnWindows(normalizedPath) : escapeArgumentOnUnix(normalizedPath));</span>
<span class="fc" id="L53">	}</span>

	/**
	 * Appends redirect operations of {@code processBuilder} to {@code builder}.
	 *
	 * @param builder        the builder to append to
	 * @param processBuilder the process builder, which information to handle
	 */
	@SuppressWarnings(&quot;PMD.CyclomaticComplexity&quot;)
	private static void appendRedirects(final StringBuilder builder, final ProcessBuilder processBuilder) {
		// Standard Input
<span class="fc" id="L64">		final Redirect input = processBuilder.redirectInput();</span>
<span class="pc bpc" id="L65" title="1 of 4 branches missed.">		if (input.type() == Type.READ &amp;&amp; input.file() != null) {</span>
<span class="fc" id="L66">			appendRedirect(builder, &quot;&lt;&quot;, input.file());</span>
		}
		// Standard Output
<span class="fc" id="L69">		final Redirect output = processBuilder.redirectOutput();</span>
<span class="pc bpc" id="L70" title="3 of 4 branches missed.">		if (output.type() == Type.APPEND &amp;&amp; output.file() != null) {</span>
<span class="nc" id="L71">			appendRedirect(builder, &quot;&gt;&gt;&quot;, output.file());</span>
<span class="pc bpc" id="L72" title="1 of 4 branches missed.">		} else if (output.type() == Type.WRITE &amp;&amp; output.file() != null) {</span>
<span class="fc" id="L73">			appendRedirect(builder, &quot;&gt;&quot;, output.file());</span>
		}
		// Standard Error
<span class="fc bfc" id="L76" title="All 2 branches covered.">		if (processBuilder.redirectErrorStream()) {</span>
<span class="fc" id="L77">			builder.append(&quot; 2&gt;&amp;1&quot;);</span>
		} else {
<span class="fc" id="L79">			final Redirect error = processBuilder.redirectError();</span>
<span class="pc bpc" id="L80" title="3 of 4 branches missed.">			if (error.type() == Type.APPEND &amp;&amp; error.file() != null) {</span>
<span class="nc" id="L81">				appendRedirect(builder, &quot;2&gt;&gt;&quot;, error.file());</span>
<span class="pc bpc" id="L82" title="1 of 4 branches missed.">			} else if (error.type() == Type.WRITE &amp;&amp; error.file() != null) {</span>
<span class="fc" id="L83">				appendRedirect(builder, &quot;2&gt;&quot;, error.file());</span>
			}
		}
<span class="fc" id="L86">	}</span>

	/**
	 * Escapes {@code argument} as command line argument for Unix.
	 *
	 * &lt;p&gt;
	 * based on &lt;a href=
	 * &quot;https://www.gnu.org/software/bash/manual/bash.html#Double-Quotes&quot;&gt;&quot;3.1.2.3
	 * Double Quotes&quot; of the Bash Reference Manual&lt;/a&gt;
	 *
	 * @param argument the argument to escape
	 * @return the escaped argument
	 */
	@PackagePrivate
	static String escapeArgumentOnUnix(final String argument) {
		// No need to quote and escape in case of clearly safe characters
<span class="fc bfc" id="L102" title="All 2 branches covered.">		if (Strings.matches(argument, UNIX_SAFE_ARGUMENT_PATTERN)) {</span>
<span class="fc" id="L103">			return argument;</span>
		}
		// Wrap in double quotes and escape characters with special meanings
<span class="fc" id="L106">		return '\&quot;' + Strings.replaceAll(argument, UNIX_BACKSLASH_SPECIAL_MEANING_CHARACTER_PATTERN, &quot;\\\\$0&quot;) + '\&quot;';</span>
	}

	/**
	 * Escapes {@code argument} as command line argument for Windows.
	 *
	 * @param argument the argument to escape
	 * @return the escaped argument
	 */
	@PackagePrivate
	@SuppressWarnings({&quot;checkstyle:IllegalInstantiation&quot;, &quot;checkstyle:XIllegalTypeCustom&quot;})
	static String escapeArgumentOnWindows(final String argument) {
<span class="fc" id="L118">		final StringBuffer buffer = new StringBuffer();</span>
		// The argument needs to be wrapped in double quotes in case of space characters
<span class="fc bfc" id="L120" title="All 4 branches covered.">		final boolean quote = argument.isEmpty() || Strings.find(argument, WINDOWS_SPACE_CHARACTER_PATTERN);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">		if (quote) {</span>
<span class="fc" id="L122">			buffer.append('\&quot;');</span>
		}
<span class="fc" id="L124">		final Matcher matcher = WINDOWS_DOUBLE_QUOTE_PATTERN.matcher(argument);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">		while (matcher.find()) {</span>
<span class="fc" id="L126">			matcher.appendReplacement(buffer, &quot;&quot;);</span>
			// In case of a double quote trailing backslashes need to be duplicated and the
			// found double quote needs to be escaped and appended.
<span class="fc bfc" id="L129" title="All 4 branches covered.">			for (int index = buffer.length() - 1; index &gt; -1 &amp;&amp; buffer.charAt(index) == '\\'; index -= 1) {</span>
<span class="fc" id="L130">				buffer.append('\\');</span>
			}
<span class="fc" id="L132">			buffer.append(&quot;\\\&quot;&quot;);</span>
		}
<span class="fc" id="L134">		matcher.appendTail(buffer);</span>
		// In case of quoting trailing backslashes need to be duplicated and the
		// trailing double quote needs to be appended.
<span class="fc bfc" id="L137" title="All 2 branches covered.">		if (quote) {</span>
<span class="pc bpc" id="L138" title="1 of 4 branches missed.">			for (int index = buffer.length() - 1; index &gt; -1 &amp;&amp; buffer.charAt(index) == '\\'; index -= 1) {</span>
<span class="fc" id="L139">				buffer.append('\\');</span>
			}
<span class="fc" id="L141">			buffer.append('\&quot;');</span>
		}
<span class="fc" id="L143">		return buffer.toString();</span>
	}

	/**
	 * Returns a command to launch {@code processBuilder} via command line.
	 *
	 * &lt;p&gt;
	 * This method is most likely used for logging and user output or debugging.
	 *
	 * &lt;p&gt;
	 * The results of this method depend on the Operating System as command line
	 * arguments on Unix and Windows are quoted and escaped differently.
	 *
	 * @param processBuilder          the process definition
	 * @param prependWorkingDirectory if {@code true} the working directory of
	 *                                {@code processBuilder} is prepended, else the
	 *                                returned value consists of the command line
	 *                                only.
	 * @return the escaped command
	 */
	public static String toCommandLine(final ProcessBuilder processBuilder, final boolean prependWorkingDirectory) {
<span class="fc" id="L164">		final StringBuilder builder = new StringBuilder();</span>
		// Working Directory
<span class="fc bfc" id="L166" title="All 2 branches covered.">		if (prependWorkingDirectory) {</span>
<span class="fc" id="L167">			builder.append(Nullables.orElseGet(processBuilder.directory(), () -&gt; Paths.get(&quot;.&quot;).toAbsolutePath().normalize().toString())).append(&quot;&gt; &quot;);</span>
		}
		// Command and Arguments
<span class="fc bfc" id="L170" title="All 2 branches covered.">		final UnaryOperator&lt;String&gt; escapeArgument = SystemUtils.isWindows() ? ProcessBuilders::escapeArgumentOnWindows : ProcessBuilders::escapeArgumentOnUnix;</span>
<span class="fc" id="L171">		builder.append(processBuilder.command().stream().map(escapeArgument).collect(joining(&quot; &quot;)));</span>
		// Redirects (Standard Input, Output, Error)
<span class="fc" id="L173">		appendRedirects(builder, processBuilder);</span>
<span class="fc" id="L174">		return builder.toString();</span>
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private ProcessBuilders() {
		throw new java.lang.UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>