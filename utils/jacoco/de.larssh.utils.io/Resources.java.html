<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Resources.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Utilities</a> &gt; <a href="index.source.html" class="el_package">de.larssh.utils.io</a> &gt; <span class="el_source">Resources.java</span></div><h1>Resources.java</h1><pre class="source lang-java linenums">// Generated by delombok at Wed Mar 15 08:49:05 UTC 2023
package de.larssh.utils.io;

import static de.larssh.utils.SystemUtils.DEFAULT_FILE_NAME_SEPARATOR;
import static de.larssh.utils.SystemUtils.DEFAULT_FILE_NAME_SEPARATOR_CHAR;
import static de.larssh.utils.SystemUtils.FILE_EXTENSION_SEPARATOR_CHAR;
import static java.util.Collections.emptyMap;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.URI;
import java.net.URL;
import java.nio.file.FileSystemNotFoundException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Enumeration;
import java.util.Optional;
import java.util.jar.JarInputStream;
import java.util.jar.Manifest;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import de.larssh.utils.Nullables;
import de.larssh.utils.collection.Enumerations;
import de.larssh.utils.text.Patterns;
import de.larssh.utils.text.Strings;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * This class contains helper methods for loading and handling resources.
 *
 * &lt;p&gt;
 * The commonly used methods to load resources might differ when running from
 * JAR instead of running from local file system. These methods make sure
 * behavior is the same and code works in both situations.
 */
public final class Resources {
	/**
	 * File extension for Java class files
	 */
	private static final String FILE_EXTENSION_CLASS = &quot;class&quot;;
	/**
	 * Pattern to check for a leading previous folder indicator
	 */
<span class="fc" id="L45">	private static final Pattern PATTERN_CHECK_LEASING_PREVIOUS_FOLDER = Pattern.compile(&quot;^/?\\.\\.(/|$)&quot;);</span>
	/**
	 * Pattern to find and remove duplicate slashes and current folder indicators
	 */
<span class="fc" id="L49">	private static final Pattern PATTERN_FIX_CURRENT_FOLDER = Pattern.compile(&quot;/(\\.?/)+&quot;);</span>
	/**
	 * Pattern to find the path to a JAR inside an URL string with JAR protocol
	 */
<span class="fc" id="L53">	private static final Pattern PATTERN_JAR_FROM_URL = Pattern.compile(&quot;(?i)^jar:(?&lt;pathToJar&gt;.*)![^!]*$&quot;);</span>

	/**
	 * Normalizes and checks {@code resource} as path for accessing resources
	 * safely.
	 *
	 * @param resource the path to normalize and check
	 * @return the normalized path
	 */
	@SuppressWarnings({&quot;checkstyle:SuppressWarnings&quot;, &quot;resource&quot;})
	private static String checkAndFixResourcePath(final Path resource) {
<span class="fc" id="L64">		String path = resource.normalize().toString();</span>
		// Normalize the file systems separator
<span class="fc" id="L66">		path = path.replace(resource.getFileSystem().getSeparator(), DEFAULT_FILE_NAME_SEPARATOR);</span>
		// Remove duplicate slashes and current folder indicators
<span class="fc" id="L68">		path = Strings.replaceAll(path, PATTERN_FIX_CURRENT_FOLDER, DEFAULT_FILE_NAME_SEPARATOR);</span>
		// Check for empty path
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">		if (path.isEmpty()) {</span>
<span class="nc" id="L71">			throw new ResourcePathException(&quot;The resource path must not be empty.&quot;);</span>
		}
		// Check for root path
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">		if (DEFAULT_FILE_NAME_SEPARATOR.equals(path)) {</span>
<span class="nc" id="L75">			throw new ResourcePathException(&quot;The resource path must not point to root.&quot;);</span>
		}
		// Check for leading previous folder indicator
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">		if (Strings.find(path, PATTERN_CHECK_LEASING_PREVIOUS_FOLDER)) {</span>
<span class="nc" id="L79">			throw new ResourcePathException(&quot;The resource path \&quot;%s\&quot; must not point to a location prior root.&quot;, resource.toString());</span>
		}
<span class="fc" id="L81">		return path;</span>
	}

	/**
	 * Converts {@code url} to a Path object creating a
	 * {@link java.nio.file.FileSystem} if not yet existing.
	 *
	 * @param url URL string
	 * @return path
	 */
	@SuppressWarnings({&quot;checkstyle:SuppressWarnings&quot;, &quot;PMD.PreserveStackTrace&quot;, &quot;resource&quot;})
	private static Path createPath(final String url) {
<span class="fc" id="L93">		final URI uri = URI.create(url);</span>
		try {
<span class="fc" id="L95">			return Paths.get(uri);</span>
<span class="nc" id="L96">		} catch (final FileSystemNotFoundException fileSystemNotFoundException) {</span>
			try {
<span class="nc" id="L98">				FileSystems.newFileSystem(uri, emptyMap());</span>
<span class="nc" id="L99">			} catch (final IOException e) {</span>
<span class="nc" id="L100">				e.addSuppressed(fileSystemNotFoundException);</span>
<span class="nc" id="L101">				throw new UncheckedIOException(e);</span>
<span class="nc" id="L102">			}</span>
<span class="nc" id="L103">			return Paths.get(uri);</span>
		}
	}

	/**
	 * Validates if {@code path} ends with {@code end} case sensitively.
	 *
	 * &lt;p&gt;
	 * In comparison to {@link Path#endsWith(Path)} this method works purely string
	 * based instead of taking the paths {@link java.nio.file.FileSystem} into
	 * account.
	 *
	 * @param path the full path with actual character casing
	 * @param end  the path end as given by the developer
	 * @return {@code true} if {@code path} ends with {@code end} case sensitively,
	 *         else {@code false}
	 */
	@SuppressFBWarnings(value = &quot;EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS&quot;, justification = &quot;should not happen on regular usage&quot;)
	private static boolean endsPathWithCaseSensitive(final Path path, final Path end) {
		Path canonicalPath;
		try {
<span class="fc" id="L124">			canonicalPath = path.toFile().getCanonicalFile().toPath();</span>
<span class="nc" id="L125">		} catch (@SuppressWarnings(&quot;unused&quot;) final UnsupportedOperationException e) {</span>
<span class="nc" id="L126">			canonicalPath = path;</span>
<span class="nc" id="L127">		} catch (final IOException e) {</span>
			// If an I/O error occurs, which is possible because the construction of the
			// canonical pathname may require file system queries
<span class="nc" id="L130">			throw new UncheckedIOException(e);</span>
<span class="pc" id="L131">		}</span>
<span class="fc" id="L132">		final int pathNames = canonicalPath.getNameCount();</span>
<span class="fc" id="L133">		final int endNames = end.getNameCount();</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">		if (pathNames &lt; endNames) {</span>
<span class="nc" id="L135">			return false;</span>
		}
<span class="fc bfc" id="L137" title="All 2 branches covered.">		for (int index = endNames - 1; index &gt;= 0; index -= 1) {</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">			if (!canonicalPath.getName(pathNames - endNames + index).toString().equals(end.getName(index).toString())) {</span>
<span class="nc" id="L139">				return false;</span>
			}
		}
<span class="fc" id="L142">		return true;</span>
	}

	/**
	 * Returns the class loader which was used to load {@code clazz} or the system
	 * class loader if {@code clazz} was loaded by the system class loader.
	 *
	 * @param clazz the class
	 * @return either the classes class loader or the system class loader
	 */
	@SuppressWarnings(&quot;PMD.UseProperClassLoader&quot;)
	private static ClassLoader getClassLoader(final Class&lt;?&gt; clazz) {
<span class="fc" id="L154">		return Nullables.orElseGet(clazz.getClassLoader(), ClassLoader::getSystemClassLoader);</span>
	}

	/**
	 * Determine the class file that {@code clazz} is defined in. Classes with no
	 * own class file result in {@link Optional#empty()}.
	 *
	 * &lt;p&gt;
	 * This method might load (without closing) a {@link java.nio.file.FileSystem}
	 * to handle a JAR archive.
	 *
	 * &lt;p&gt;
	 * Attention: &lt;a href=
	 * &quot;https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8131067&quot;&gt;https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8131067&lt;/a&gt;
	 *
	 * @param clazz class
	 * @return path to the the class file
	 */
	public static Optional&lt;Path&gt; getPathToClass(final Class&lt;?&gt; clazz) {
<span class="nc" id="L173">		return getUrlToClass(clazz).map(URL::toString).map(Resources::createPath);</span>
	}

	/**
	 * Determine the JAR file that {@code clazz} is loaded from.
	 *
	 * &lt;p&gt;
	 * Classes outside of a JAR or with no own class file result in
	 * {@link Optional#empty()}.
	 *
	 * @param clazz class
	 * @return path to the the JAR file
	 */
	public static Optional&lt;Path&gt; getPathToJar(final Class&lt;?&gt; clazz) {
<span class="nc" id="L187">		return getUrlToClass(clazz).map(URL::toString).flatMap(url -&gt; Patterns.matches(PATTERN_JAR_FROM_URL, url)).map(matcher -&gt; matcher.group(&quot;pathToJar&quot;)).map(Resources::createPath);</span>
	}

	/**
	 * Finds the path to {@code resource} using the class loader's resource lookup
	 * algorithm.
	 *
	 * &lt;p&gt;
	 * The commonly used method {@link ClassLoader#getResource(String)} might differ
	 * when running from JAR instead of running from local file system. This method
	 * makes sure behavior is the same and code works in both situations.
	 *
	 * &lt;p&gt;
	 * Calling this might load the {@link java.nio.file.FileSystem} that is
	 * registered for handling JAR files. If no file or folder is found
	 * {@link Optional#empty()} is returned.
	 *
	 * @param classLoader class loader to use for resource lookup
	 * @param resource    path to the resource to find
	 * @return the path to the resource
	 */
	public static Optional&lt;Path&gt; getResource(final ClassLoader classLoader, final Path resource) {
<span class="fc" id="L209">		final String fixedPath = checkAndFixResourcePath(resource);</span>
<span class="fc" id="L210">		return Optional.ofNullable(classLoader.getResource(fixedPath)).map(URL::toString).map(Resources::createPath).filter(path -&gt; endsPathWithCaseSensitive(path, Paths.get(fixedPath)));</span>
	}

	/**
	 * Finds the path to {@code resource} relative to {@code clazz}.
	 *
	 * &lt;p&gt;
	 * The commonly used method {@link Class#getResource(String)} might differ when
	 * running from JAR instead of running from local file system. This method makes
	 * sure behavior is the same and code works in both situations.
	 *
	 * &lt;p&gt;
	 * Calling this might load the {@link java.nio.file.FileSystem} that is
	 * registered for handling JAR files. If no file or folder is found
	 * {@link Optional#empty()} is returned.
	 *
	 * @param clazz    class to use for resource lookup
	 * @param resource relative path to the resource to find
	 * @return the path to the resource
	 */
	@SuppressFBWarnings(value = &quot;PATH_TRAVERSAL_IN&quot;, justification = &quot;processing as described in JavaDoc&quot;)
	public static Optional&lt;Path&gt; getResourceRelativeTo(final Class&lt;?&gt; clazz, final Path resource) {
<span class="fc" id="L232">		return getResourceStringToClass(clazz).map(Paths::get).map(Path::getParent).map(path -&gt; path.resolve(resource)).flatMap(absoluteResource -&gt; getResource(getClassLoader(clazz), absoluteResource));</span>
	}

	/**
	 * Finds the paths to {@code resource} using the class loader's resource lookup
	 * algorithm. Instead of {@link #getResource(ClassLoader, Path)} this method
	 * returns not only the first matching resource, but also the shadowed resources
	 * based on the class loaders hierarchy.
	 *
	 * &lt;p&gt;
	 * The commonly used method {@link ClassLoader#getResources(String)} might
	 * differ when running from JAR instead of running from local file system. This
	 * method makes sure behavior is the same and code works in both situations.
	 *
	 * &lt;p&gt;
	 * Calling this might load the {@link java.nio.file.FileSystem} that is
	 * registered for handling JAR files. If no file or folder is found
	 * {@link Optional#empty()} is returned.
	 *
	 * @param classLoader class loader to use for resource lookup
	 * @param resource    path to the resource to find
	 * @return the paths of the found resources
	 */
	@SuppressFBWarnings(value = &quot;EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS&quot;, justification = &quot;converting to unchecked IOException&quot;)
	public static Stream&lt;Path&gt; getResources(final ClassLoader classLoader, final Path resource) {
<span class="nc" id="L257">		final String fixedPath = checkAndFixResourcePath(resource);</span>
		final Enumeration&lt;URL&gt; enumeration;
		try {
<span class="nc" id="L260">			enumeration = classLoader.getResources(fixedPath);</span>
<span class="nc" id="L261">		} catch (final IOException e) {</span>
<span class="nc" id="L262">			throw new UncheckedIOException(e);</span>
<span class="nc" id="L263">		}</span>
<span class="nc" id="L264">		return Enumerations.stream(enumeration).map(URL::toString).map(Resources::createPath).filter(path -&gt; endsPathWithCaseSensitive(path, Paths.get(fixedPath)));</span>
	}

	/**
	 * Finds the paths to {@code resource} relative to {@code clazz}. Instead of
	 * {@link #getResourceRelativeTo(Class, Path)} this method returns not only the
	 * first matching resource, but also the shadowed resources based on the class
	 * loaders hierarchy.
	 *
	 * &lt;p&gt;
	 * Calling this might load the {@link java.nio.file.FileSystem} that is
	 * registered for handling JAR files. If no file or folder is found
	 * {@link Optional#empty()} is returned.
	 *
	 * @param clazz    class to use for resource lookup
	 * @param resource path to the resource to find
	 * @return the paths of the found resources
	 */
	@SuppressFBWarnings(value = &quot;PATH_TRAVERSAL_IN&quot;, justification = &quot;processing as described in JavaDoc&quot;)
	public static Stream&lt;Path&gt; getResourcesRelativeTo(final Class&lt;?&gt; clazz, final Path resource) {
<span class="nc" id="L284">		return getResourceStringToClass(clazz).map(Paths::get).map(Path::getParent).map(path -&gt; path.resolve(resource)).map(absoluteResource -&gt; getResources(getClassLoader(clazz), absoluteResource)).orElseGet(Stream::empty);</span>
	}

	/**
	 * Determine the resource string to the class file that {@code clazz} is defined
	 * in. Classes with probably no own class file result in
	 * {@link Optional#empty()}.
	 *
	 * @param clazz the class
	 * @return resource string to the class file
	 */
	private static Optional&lt;String&gt; getResourceStringToClass(final Class&lt;?&gt; clazz) {
<span class="fc" id="L296">		final String className = clazz.getName();</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">		return className.indexOf(FILE_EXTENSION_SEPARATOR_CHAR) == -1 ? Optional.empty() : Optional.of(className.replace(FILE_EXTENSION_SEPARATOR_CHAR, DEFAULT_FILE_NAME_SEPARATOR_CHAR) + FILE_EXTENSION_SEPARATOR_CHAR + FILE_EXTENSION_CLASS);</span>
	}

	/**
	 * Determine the class file that {@code clazz} is defined in.
	 *
	 * &lt;p&gt;
	 * Classes with no own class file result in {@link Optional#empty()}.
	 *
	 * @param clazz class
	 * @return URL to the the class file
	 */
	private static Optional&lt;URL&gt; getUrlToClass(final Class&lt;?&gt; clazz) {
<span class="nc" id="L310">		return getResourceStringToClass(clazz).map(resource -&gt; getClassLoader(clazz).getResource(resource));</span>
	}

	/**
	 * Reads the {@link Manifest} of the JAR file that {@code clazz} has been loaded
	 * from.
	 *
	 * &lt;p&gt;
	 * Classes outside of a JAR or with no own class file or JARs with no manifest
	 * result in {@link Optional#empty()}.
	 *
	 * @param clazz class
	 * @return manifest
	 * @throws IOException if an I/O error occurs
	 */
	public static Optional&lt;Manifest&gt; readManifest(final Class&lt;?&gt; clazz) throws IOException {
<span class="nc" id="L326">		final Optional&lt;Path&gt; path = getPathToJar(clazz);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">		if (!path.isPresent()) {</span>
<span class="nc" id="L328">			return Optional.empty();</span>
		}
<span class="nc" id="L330">		try (JarInputStream inputStream = new JarInputStream(Files.newInputStream(path.get()))) {</span>
<span class="nc" id="L331">			return Optional.ofNullable(inputStream.getManifest());</span>
		}
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private Resources() {
		throw new java.lang.UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>