<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Optionals.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Parent POM</a> &gt; <a href="../index.html" class="el_bundle">utils</a> &gt; <a href="index.source.html" class="el_package">de.larssh.utils</a> &gt; <span class="el_source">Optionals.java</span></div><h1>Optionals.java</h1><pre class="source lang-java linenums">// Generated by delombok at Sat Jan 16 00:30:52 UTC 2021
package de.larssh.utils;

import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.ToDoubleFunction;
import java.util.function.ToIntFunction;
import java.util.function.ToLongFunction;
import java.util.stream.Stream;
import de.larssh.utils.text.Characters;
import de.larssh.utils.text.Strings;
import edu.umd.cs.findbugs.annotations.Nullable;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * This class contains helper methods for {@link Optional}.
 */
@SuppressWarnings(&quot;PMD.GodClass&quot;)
public final class Optionals {
	/**
	 * Creates a {@link Comparator} to compare {@link Optional}s based on the inner
	 * types {@link Comparable} implementation.
	 *
	 * @param &lt;T&gt; optional value type
	 * @return comparator for optional
	 */
	public static &lt;T extends Comparable&lt;T&gt;&gt; Comparator&lt;? super Optional&lt;? extends T&gt;&gt; comparator() {
<span class="nc" id="L37">		return comparator((first, second) -&gt; {</span>
<span class="nc bnc" id="L38" title="All 2 branches missed.">			if (first == null) {</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">				if (second == null) {</span>
<span class="nc" id="L40">					return 0;</span>
				}
				// The integer value MIN_VALUE cannot be negated in the integer range
				// as [-MIN_VALUE] is mathematically equal to [MAX_VALUE + 1].
<span class="nc" id="L44">				final int compare = second.compareTo(null);</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">				return compare == Integer.MIN_VALUE ? Integer.MAX_VALUE : -compare;</span>
			}
<span class="nc" id="L47">			return first.compareTo(second);</span>
		});
	}

	/**
	 * Wraps a {@link Comparator} to allow compare {@link Optional}s.
	 *
	 * &lt;p&gt;
	 * When comparing {@code comparator} is called with the optionals object if
	 * present or {@code null}. Therefore it needs to handle null values
	 * appropriately. Use {@link Comparator#nullsFirst(Comparator)} and
	 * {@link Comparator#nullsLast(Comparator)} if your comparator does not.
	 *
	 * @param &lt;T&gt;        optional value type
	 * @param comparator optional value comparator
	 * @return comparator for optional
	 */
	public static &lt;T&gt; Comparator&lt;? super Optional&lt;? extends T&gt;&gt; comparator(final Comparator&lt;? super T&gt; comparator) {
<span class="nc" id="L65">		return (first, second) -&gt; comparator.compare(Nullables.map(second, optional -&gt; optional.orElse(null)), Nullables.map(second, optional -&gt; optional.orElse(null)));</span>
	}

	/**
	 * If a value is present, apply the provided {@link OptionalDouble}-bearing
	 * mapping function to it, return that result, otherwise return an empty
	 * {@link OptionalDouble}. This method is similar to
	 * {@link #mapToDouble(Optional, ToDoubleFunction)}, but the provided mapper is
	 * one whose result is already an {@code OptionalDouble}, and if invoked,
	 * {@code flatMapToDouble} does not wrap it with an additional
	 * {@link OptionalDouble}.
	 *
	 * @param &lt;T&gt;      element type
	 * @param optional optional value
	 * @param mapper   a mapping function to apply to the value, if present the
	 *                 mapping function
	 * @return the result of applying an {@link OptionalDouble}-bearing mapping
	 *         function to the value of this {@link OptionalDouble}, if a value is
	 *         present, otherwise an empty {@link OptionalDouble}
	 */
	public static &lt;T&gt; OptionalDouble flatMapToDouble(final Optional&lt;T&gt; optional, final Function&lt;? super T, OptionalDouble&gt; mapper) {
<span class="nc bnc" id="L86" title="All 2 branches missed.">		return optional.isPresent() ? mapper.apply(optional.get()) : OptionalDouble.empty();</span>
	}

	/**
	 * If a value is present, apply the provided {@link OptionalInt}-bearing mapping
	 * function to it, return that result, otherwise return an empty
	 * {@link OptionalInt}. This method is similar to
	 * {@link #mapToInt(Optional, ToIntFunction)}, but the provided mapper is one
	 * whose result is already an {@code OptionalInt}, and if invoked,
	 * {@code flatMap} does not wrap it with an additional {@link OptionalInt}.
	 *
	 * @param &lt;T&gt;      element type
	 * @param optional optional value
	 * @param mapper   a mapping function to apply to the value, if present the
	 *                 mapping function
	 * @return the result of applying an {@link OptionalInt}-bearing mapping
	 *         function to the value of this {@link OptionalInt}, if a value is
	 *         present, otherwise an empty {@link OptionalInt}
	 */
	public static &lt;T&gt; OptionalInt flatMapToInt(final Optional&lt;T&gt; optional, final Function&lt;? super T, OptionalInt&gt; mapper) {
<span class="nc bnc" id="L106" title="All 2 branches missed.">		return optional.isPresent() ? mapper.apply(optional.get()) : OptionalInt.empty();</span>
	}

	/**
	 * If a value is present, apply the provided {@link OptionalLong}-bearing
	 * mapping function to it, return that result, otherwise return an empty
	 * {@link OptionalLong}. This method is similar to
	 * {@link #mapToLong(Optional, ToLongFunction)}, but the provided mapper is one
	 * whose result is already an {@code OptionalLong}, and if invoked,
	 * {@code flatMapToDouble} does not wrap it with an additional
	 * {@link OptionalLong}.
	 *
	 * @param &lt;T&gt;      element type
	 * @param optional optional value
	 * @param mapper   a mapping function to apply to the value, if present the
	 *                 mapping function
	 * @return the result of applying an {@link OptionalLong}-bearing mapping
	 *         function to the value of this {@link OptionalLong}, if a value is
	 *         present, otherwise an empty {@link OptionalLong}
	 */
	public static &lt;T&gt; OptionalLong flatMapToLong(final Optional&lt;T&gt; optional, final Function&lt;? super T, OptionalLong&gt; mapper) {
<span class="nc bnc" id="L127" title="All 2 branches missed.">		return optional.isPresent() ? mapper.apply(optional.get()) : OptionalLong.empty();</span>
	}

	/**
	 * Returns an {@link Optional} describing the first value matching the predicate
	 * {@code isPresent}. Returns an empty {@link Optional} if no element matches.
	 *
	 * @param &lt;T&gt;       type of the return value
	 * @param isPresent predicate to match
	 * @param suppliers any number of value suppliers, which values to test,
	 *                  evaluated in a lazy manner
	 * @return an {@link Optional} describing the first value matching the predicate
	 *         {@code isPresent}, an empty {@link Optional} if no element matches
	 */
	@SafeVarargs
	public static &lt;T&gt; Optional&lt;T&gt; getFirst(final Predicate&lt;? super T&gt; isPresent, final Supplier&lt;? extends T&gt;... suppliers) {
<span class="nc bnc" id="L143" title="All 2 branches missed.">		for (final Supplier&lt;? extends T&gt; supplier : suppliers) {</span>
<span class="nc" id="L144">			final T value = supplier.get();</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">			if (isPresent.test(value)) {</span>
<span class="nc" id="L146">				return Optional.ofNullable(value);</span>
			}
		}
<span class="nc" id="L149">		return Optional.empty();</span>
	}

	/**
	 * Returns an {@link Optional} describing the first value matching the predicate
	 * {@code isPresent}. Returns an empty {@link Optional} if no element matches.
	 *
	 * @param &lt;T&gt;       type of the return value
	 * @param isPresent predicate to match
	 * @param values    any number of values to test
	 * @return an {@link Optional} describing the first value matching the predicate
	 *         {@code isPresent}, an empty {@link Optional} if no element matches
	 */
	@SafeVarargs
	public static &lt;T&gt; Optional&lt;T&gt; getFirstValue(final Predicate&lt;? super T&gt; isPresent, final T... values) {
<span class="nc bnc" id="L164" title="All 2 branches missed.">		for (final T value : values) {</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">			if (isPresent.test(value)) {</span>
<span class="nc" id="L166">				return Optional.ofNullable(value);</span>
			}
		}
<span class="nc" id="L169">		return Optional.empty();</span>
	}

	/**
	 * If a value is present, returns an {@link OptionalDouble} describing the
	 * result. Otherwise returns an empty {@link OptionalDouble}.
	 *
	 * @param optional optional value
	 * @return an {@link OptionalDouble} describing the value of {@code optional},
	 *         if a value is present, otherwise an empty {@link OptionalDouble}
	 */
	@SuppressFBWarnings(value = &quot;FII_USE_METHOD_REFERENCE&quot;, justification = &quot;Missing ToLongFunction.identity()&quot;)
	public static OptionalDouble mapToDouble(final Optional&lt;Double&gt; optional) {
<span class="nc" id="L182">		return mapToDouble(optional, value -&gt; value);</span>
	}

	/**
	 * If a value is present, applies {@code mapper} to {@code optional} and returns
	 * an {@link OptionalDouble} describing the result. Otherwise returns an empty
	 * {@link OptionalDouble}.
	 *
	 * @param &lt;T&gt;      element type
	 * @param optional optional value
	 * @param mapper   a mapping function to apply to the value, if present
	 * @return an {@link OptionalDouble} describing the result of applying
	 *         {@code mapper} function to the value of {@code optional}, if a value
	 *         is present, otherwise an empty {@link OptionalDouble}
	 */
	public static &lt;T&gt; OptionalDouble mapToDouble(final Optional&lt;T&gt; optional, final ToDoubleFunction&lt;? super T&gt; mapper) {
<span class="nc bnc" id="L198" title="All 2 branches missed.">		return optional.isPresent() ? OptionalDouble.of(mapper.applyAsDouble(optional.get())) : OptionalDouble.empty();</span>
	}

	/**
	 * If a value is present, returns an {@link OptionalInt} describing the result.
	 * Otherwise returns an empty {@link OptionalInt}.
	 *
	 * @param optional optional value
	 * @return an {@link OptionalInt} describing the value of {@code optional}, if a
	 *         value is present, otherwise an empty {@link OptionalInt}
	 */
	@SuppressFBWarnings(value = &quot;FII_USE_METHOD_REFERENCE&quot;, justification = &quot;Missing ToLongFunction.identity()&quot;)
	public static OptionalInt mapToInt(final Optional&lt;Integer&gt; optional) {
<span class="nc" id="L211">		return mapToInt(optional, value -&gt; value);</span>
	}

	/**
	 * If a value is present, applies {@code mapper} to {@code optional} and returns
	 * an {@link OptionalInt} describing the result. Otherwise returns an empty
	 * {@link OptionalInt}.
	 *
	 * @param &lt;T&gt;      element type
	 * @param optional optional value
	 * @param mapper   a mapping function to apply to the value, if present
	 * @return an {@link OptionalInt} describing the result of applying
	 *         {@code mapper} function to the value of {@code optional}, if a value
	 *         is present, otherwise an empty {@link OptionalInt}
	 */
	public static &lt;T&gt; OptionalInt mapToInt(final Optional&lt;T&gt; optional, final ToIntFunction&lt;? super T&gt; mapper) {
<span class="nc bnc" id="L227" title="All 2 branches missed.">		return optional.isPresent() ? OptionalInt.of(mapper.applyAsInt(optional.get())) : OptionalInt.empty();</span>
	}

	/**
	 * If a value is present, returns an {@link OptionalLong} describing the result.
	 * Otherwise returns an empty {@link OptionalLong}.
	 *
	 * @param optional optional value
	 * @return an {@link OptionalLong} describing the value of {@code optional}, if
	 *         a value is present, otherwise an empty {@link OptionalLong}
	 */
	@SuppressFBWarnings(value = &quot;FII_USE_METHOD_REFERENCE&quot;, justification = &quot;Missing ToLongFunction.identity()&quot;)
	public static OptionalLong mapToLong(final Optional&lt;Long&gt; optional) {
<span class="nc" id="L240">		return mapToLong(optional, value -&gt; value);</span>
	}

	/**
	 * If a value is present, applies {@code mapper} to {@code optional} and returns
	 * an {@link OptionalLong} describing the result. Otherwise returns an empty
	 * {@link OptionalLong}.
	 *
	 * @param &lt;T&gt;      element type
	 * @param optional optional value
	 * @param mapper   a mapping function to apply to the value, if present
	 * @return an {@link OptionalLong} describing the result of applying
	 *         {@code mapper} function to the value of {@code optional}, if a value
	 *         is present, otherwise an empty {@link OptionalLong}
	 */
	public static &lt;T&gt; OptionalLong mapToLong(final Optional&lt;T&gt; optional, final ToLongFunction&lt;? super T&gt; mapper) {
<span class="nc bnc" id="L256" title="All 2 branches missed.">		return optional.isPresent() ? OptionalLong.of(mapper.applyAsLong(optional.get())) : OptionalLong.empty();</span>
	}

	/**
	 * Returns an {@link Optional} describing the specified value, if non-null and
	 * non-empty, otherwise returns an empty {@link Optional}. The term &lt;i&gt;empty&lt;/i&gt;
	 * is described by {@code isEmpty}.
	 *
	 * @param &lt;T&gt;     value type
	 * @param isEmpty predicate describing the term &lt;i&gt;empty&lt;/i&gt;
	 * @param value   the possibly-null-or-empty value to describe
	 * @return an {@link Optional} with a present value if the specified value is
	 *         non-null and non-empty, otherwise an empty {@link Optional}
	 */
	public static &lt;T&gt; Optional&lt;T&gt; ofNon(final Predicate&lt;? super T&gt; isEmpty, @Nullable final T value) {
<span class="nc bnc" id="L271" title="All 4 branches missed.">		return value == null || isEmpty.test(value) ? Optional.empty() : Optional.of(value);</span>
	}

	/**
	 * Returns an {@link Optional} describing the specified string, if non-null and
	 * non-blank, otherwise returns an empty {@link Optional}.
	 *
	 * @param string the possibly-null-or-blank string to describe
	 * @return an {@link Optional} with a present value if the specified string is
	 *         non-null and non-empty after being trimmed, otherwise an empty
	 *         {@link Optional}
	 */
	public static Optional&lt;String&gt; ofNonBlank(@Nullable final String string) {
<span class="nc" id="L284">		return ofNon(Strings::isBlank, string);</span>
	}

	/**
	 * Returns an {@link Optional} describing the specified array, if non-null and
	 * non-empty, otherwise returns an empty {@link Optional}.
	 *
	 * @param &lt;T&gt;   array element type
	 * @param array the possibly-null-or-empty array to describe
	 * @return an {@link Optional} with a present value if the specified array is
	 *         non-null and non-empty, otherwise an empty {@link Optional}
	 */
	@SuppressWarnings(&quot;PMD.UseVarargs&quot;)
	@SuppressFBWarnings(value = &quot;UVA_USE_VAR_ARGS&quot;, justification = &quot;var args make no sense as their length is constant&quot;)
	public static &lt;T&gt; Optional&lt;T[]&gt; ofNonEmpty(@Nullable final T[] array) {
<span class="nc bnc" id="L299" title="All 2 branches missed.">		return ofNon(a -&gt; a.length == 0, array);</span>
	}

	/**
	 * Returns an {@link Optional} describing the specified collection, if non-null
	 * and non-empty, otherwise returns an empty {@link Optional}.
	 *
	 * @param &lt;T&gt;        collection and collection element type
	 * @param collection the possibly-null-or-empty collection to describe
	 * @return an {@link Optional} with a present value if the specified collection
	 *         is non-null and non-empty, otherwise an empty {@link Optional}
	 */
	public static &lt;T extends Collection&lt;?&gt;&gt; Optional&lt;T&gt; ofNonEmpty(@Nullable final T collection) {
<span class="nc" id="L312">		return ofNon(Collection::isEmpty, collection);</span>
	}

	/**
	 * Returns an {@link Optional} describing the specified string, if non-null and
	 * non-empty, otherwise returns an empty {@link Optional}.
	 *
	 * @param string the possibly-null-or-empty string to describe
	 * @return an {@link Optional} with a present value if the specified string is
	 *         non-null and non-empty, otherwise an empty {@link Optional}
	 */
	public static Optional&lt;String&gt; ofNonEmpty(@Nullable final String string) {
<span class="nc" id="L324">		return ofNon(String::isEmpty, string);</span>
	}

	/**
	 * Returns an {@link Optional} describing the specified arrays first element, if
	 * present, otherwise returns an empty {@link Optional}. Throws a
	 * {@link TooManyElementsException} if {@code array} contains more than one
	 * element.
	 *
	 * @param &lt;T&gt;   array element type
	 * @param array the array describing the element
	 * @return an {@link Optional} describing the specified arrays first element, if
	 *         present, otherwise returns an empty {@link Optional}
	 * @throws TooManyElementsException if {@code array} contains more than one
	 *                                  element
	 */
	@SuppressWarnings(&quot;PMD.UseVarargs&quot;)
	@SuppressFBWarnings(value = &quot;UVA_USE_VAR_ARGS&quot;, justification = &quot;var args make no sense as their length is constant&quot;)
	public static &lt;T&gt; Optional&lt;T&gt; ofSingle(final T[] array) {
<span class="nc bnc" id="L343" title="All 2 branches missed.">		if (array.length == 0) {</span>
<span class="nc" id="L344">			return Optional.empty();</span>
		}
<span class="nc bnc" id="L346" title="All 2 branches missed.">		if (array.length == 1) {</span>
<span class="nc" id="L347">			return Optional.ofNullable(array[0]);</span>
		}
<span class="nc" id="L349">		throw new TooManyElementsException();</span>
	}

	/**
	 * Returns an {@link Optional} describing the specified iterables first element,
	 * if present, otherwise returns an empty {@link Optional}. Throws a
	 * {@link TooManyElementsException} if {@code iterable} contains more than one
	 * element.
	 *
	 * @param &lt;T&gt;      iterable element type
	 * @param iterable the iterable describing the element
	 * @return an {@link Optional} describing the specified iterables first element,
	 *         if present, otherwise returns an empty {@link Optional}
	 * @throws TooManyElementsException if {@code iterable} contains more than one
	 *                                  element
	 */
	public static &lt;T&gt; Optional&lt;T&gt; ofSingle(final Iterable&lt;T&gt; iterable) {
<span class="nc" id="L366">		return ofSingle(iterable.iterator());</span>
	}

	/**
	 * Returns an {@link Optional} describing the specified iterators first element,
	 * if present, otherwise returns an empty {@link Optional}. Throws a
	 * {@link TooManyElementsException} if {@code iterator} contains more than one
	 * element.
	 *
	 * @param &lt;T&gt;      iterator element type
	 * @param iterator the iterator describing the element
	 * @return an {@link Optional} describing the specified iterators first element,
	 *         if present, otherwise returns an empty {@link Optional}
	 * @throws TooManyElementsException if {@code iterator} contains more than one
	 *                                  element
	 */
	@SuppressWarnings(&quot;PMD.PrematureDeclaration&quot;)
	public static &lt;T&gt; Optional&lt;T&gt; ofSingle(final Iterator&lt;T&gt; iterator) {
<span class="nc bnc" id="L384" title="All 2 branches missed.">		if (!iterator.hasNext()) {</span>
<span class="nc" id="L385">			return Optional.empty();</span>
		}
<span class="nc" id="L387">		final Optional&lt;T&gt; optional = Optional.ofNullable(iterator.next());</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">		if (iterator.hasNext()) {</span>
<span class="nc" id="L389">			throw new TooManyElementsException();</span>
		}
<span class="nc" id="L391">		return optional;</span>
	}

	/**
	 * Returns an {@link Optional} describing the specified streams first element,
	 * if present, otherwise returns an empty {@link Optional}. Throws a
	 * {@link TooManyElementsException} if {@code stream} contains more than one
	 * element.
	 *
	 * &lt;p&gt;
	 * This is a terminal operation.
	 *
	 * @param &lt;T&gt;    stream element type
	 * @param stream the stream describing the element
	 * @return an {@link Optional} describing the specified streams first element,
	 *         if present, otherwise returns an empty {@link Optional}
	 * @throws TooManyElementsException if {@code stream} contains more than one
	 *                                  element
	 */
	public static &lt;T&gt; Optional&lt;T&gt; ofSingle(final Stream&lt;T&gt; stream) {
<span class="nc" id="L411">		return ofSingle(stream.iterator());</span>
	}

	/**
	 * Returns an {@link OptionalInt} describing the specified strings first
	 * character, if present, otherwise returns an empty {@link OptionalInt}. Throws
	 * a {@link TooManyElementsException} if {@code string} contains more than one
	 * character, ignoring trailing whitespaces.
	 *
	 * &lt;p&gt;
	 * Whitespace characters are recognized using
	 * {@link Characters#isAsciiWhitespace(char)}.
	 *
	 * @param string the string describing the character
	 * @return an {@link OptionalInt} describing the specified strings first
	 *         character, if present, otherwise returns an empty {@link OptionalInt}
	 * @throws TooManyElementsException if {@code string} contains more than one
	 *                                  character, ignoring trailing whitespaces
	 */
	public static OptionalInt ofSingle(final CharSequence string) {
<span class="nc" id="L431">		final int length = string.length();</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">		if (length == 0) {</span>
<span class="nc" id="L433">			return OptionalInt.empty();</span>
		}
<span class="nc bnc" id="L435" title="All 2 branches missed.">		for (int index = 1; index &lt; length; index += 1) {</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">			if (!Characters.isAsciiWhitespace(string.charAt(index))) {</span>
<span class="nc" id="L437">				throw new TooManyElementsException();</span>
			}
		}
<span class="nc" id="L440">		return OptionalInt.of(string.charAt(0));</span>
	}

	/**
	 * Returns a stream consisting of present elements.
	 *
	 * @param &lt;T&gt;       element type
	 * @param optionals array of optional elements
	 * @return the new stream
	 */
	@SafeVarargs
	public static &lt;T&gt; Stream&lt;T&gt; stream(final Optional&lt;T&gt;... optionals) {
<span class="nc" id="L452">		return Arrays.stream(optionals).filter(Optional::isPresent).map(Optional::get);</span>
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private Optionals() {
		throw new java.lang.UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>