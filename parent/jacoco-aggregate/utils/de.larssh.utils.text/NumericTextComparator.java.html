<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>NumericTextComparator.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Parent POM</a> &gt; <a href="../index.html" class="el_bundle">utils</a> &gt; <a href="index.source.html" class="el_package">de.larssh.utils.text</a> &gt; <span class="el_source">NumericTextComparator.java</span></div><h1>NumericTextComparator.java</h1><pre class="source lang-java linenums">// Generated by delombok at Wed Sep 24 07:45:07 UTC 2025
package de.larssh.utils.text;

import java.util.Comparator;
import de.larssh.utils.annotations.PackagePrivate;
import edu.umd.cs.findbugs.annotations.Nullable;

/**
 * A {@link Comparator} that orders alpha numeric strings in &lt;i&gt;natural&lt;/i&gt;
 * order, either case sensitive or case insensitive. It is appreciated to use
 * this kind of ordering for user output.
 *
 * &lt;p&gt;
 * Because numeric values are not deserialized into numeric data types, their
 * length is not limited. Fractions are not supported and will be handled as two
 * separate numeric values.
 *
 * &lt;p&gt;
 * Numeric values can have a leading plus or minus sign when following a
 * whitespace character or at a strings start.
 *
 * &lt;p&gt;
 * The following lists some example values to demonstrate the ordering.
 * &lt;ul&gt;
 * &lt;li&gt;Banana -12 Circus
 * &lt;li&gt;Banana -5 Circus
 * &lt;li&gt;Banana +5 Circus
 * &lt;li&gt;Banana 5 Circus
 * &lt;li&gt;Banana +5 Dolphin
 * &lt;li&gt;Banana 8 Circus
 * &lt;li&gt;Banana 12 Circus
 * &lt;li&gt;Banana-5 Circus
 * &lt;li&gt;Banana-12 Circus
 * &lt;li&gt;Banana--5 Circus
 * &lt;li&gt;Elephant 5 Circus
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * This comparator permits null values.
 *
 * &lt;p&gt;
 * Note that this Comparator does &lt;em&gt;not&lt;/em&gt; take locale into account, and
 * will result in an unsatisfactory ordering for certain locales.
 */
@PackagePrivate
final class NumericTextComparator implements Comparator&lt;String&gt; {
	/**
	 * Singleton instance of {@link NumericTextComparator} to compare strings case
	 * insensitive.
	 */
	@PackagePrivate
<span class="nc" id="L52">	static final Comparator&lt;String&gt; COMPARATOR_CASE_INSENSITIVE = new NumericTextComparator(true);</span>
	/**
	 * Singleton instance of {@link NumericTextComparator} to compare strings case
	 * sensitive.
	 */
	@PackagePrivate
<span class="nc" id="L58">	static final Comparator&lt;String&gt; COMPARATOR_CASE_SENSITIVE = new NumericTextComparator(false);</span>
	/**
	 * Specifies case sensitivity for comparison
	 */
	private final boolean caseInsensitive;

	/**
	 * Compares its two arguments for numeric &lt;i&gt;and&lt;/i&gt; text order. Returns a
	 * negative integer, zero, or a positive integer as the first argument is less
	 * than, equal to, or greater than the second.
	 *
	 * &lt;p&gt;
	 * This comparator permits null values.
	 *
	 * @param first  the first char sequence to be compared
	 * @param second the second char sequence to be compared
	 * @return a negative integer, zero, or a positive integer as the first argument
	 *         is less than, equal to, or greater than the second
	 */
	@Override
	public int compare(@Nullable final String first, @Nullable final String second) {
<span class="nc bnc" id="L79" title="All 2 branches missed.">		if (first == null) {</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">			return second == null ? 0 : -1;</span>
		}
<span class="nc bnc" id="L82" title="All 2 branches missed.">		return second == null ? 1 : new NumericTextComparatorContext(first, second).compare();</span>
	}


	/**
	 * Internal context per each comparison, holding the strings to compare and
	 * their current indexes
	 */
	private final class NumericTextComparatorContext {
		/**
		 * First string to be compared
		 */
		private final String first;
		/**
		 * State of the comparison: Current index of the first string
		 */
		private int firstIndex;
		/**
		 * Length of the first string (cached)
		 */
		private final int firstLength;
		/**
		 * Second string to be compared
		 */
		private final String second;
		/**
		 * State of the comparison: Current index of the second string
		 */
		private int secondIndex;
		/**
		 * Length of the second string (cached)
		 */
		private final int secondLength;

		/* package */ /**
		 * Constructor for the internal context per each comparison, holding the strings
		 * to compare and their current indexes
		 *
		 * @param first  the first char sequence to be compared
		 * @param second the second char sequence to be compared
		 */
<span class="nc" id="L123">		NumericTextComparatorContext(final String first, final String second) {</span>
<span class="nc" id="L124">			this.first = first;</span>
<span class="nc" id="L125">			firstLength = first.length();</span>
<span class="nc" id="L126">			this.second = second;</span>
<span class="nc" id="L127">			secondLength = second.length();</span>
<span class="nc" id="L128">		}</span>

		/**
		 * Compares both strings
		 *
		 * @return comparison result
		 */
		public int compare() {
<span class="nc bnc" id="L136" title="All 2 branches missed.">			while (!isRest()) {</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">				if (isNumeric()) {</span>
<span class="nc" id="L138">					final int compared = compareSignedNumeric();</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">					if (compared != 0) {</span>
<span class="nc" id="L140">						return compared;</span>
					}
<span class="nc" id="L142">				} else {</span>
<span class="nc" id="L143">					final int compared = compareText();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">					if (compared != 0) {</span>
<span class="nc" id="L145">						return compared;</span>
					}
<span class="nc" id="L147">				}</span>
			}
<span class="nc" id="L149">			final int compared = compareRest();</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">			if (compared != 0) {</span>
<span class="nc" id="L151">				return compared;</span>
			}
<span class="nc bnc" id="L153" title="All 2 branches missed.">			return isCaseInsensitive() ? first.compareToIgnoreCase(second) : first.compareTo(second);</span>
		}

		/**
		 * Returns {@code true} if at least one of the strings end has been reached.
		 *
		 * @return {@code true} if a strings end has been reached
		 */
		private boolean isRest() {
<span class="nc bnc" id="L162" title="All 4 branches missed.">			return firstIndex &gt;= firstLength || secondIndex &gt;= secondLength;</span>
		}

		/**
		 * Returns {@code true} if at least of the strings continues with an optionally
		 * signed numeric value.
		 *
		 * &lt;p&gt;
		 * This method is used to initiate the numeric comparison. It loads one
		 * character of both strings &lt;i&gt;without&lt;/i&gt; validation.
		 *
		 * @return {@code true} if any sequence continues with an optionally signed
		 *         numeric value
		 */
		private boolean isNumeric() {
<span class="nc bnc" id="L177" title="All 8 branches missed.">			return Characters.isAsciiDigit(first.charAt(firstIndex)) || Characters.isAsciiDigit(second.charAt(secondIndex)) || isSignedNumeric(first, firstLength, firstIndex) || isSignedNumeric(second, secondLength, secondIndex);</span>
		}

		/**
		 * Returns {@code true} if {@code value} has a signed numeric value at
		 * {@code index}.
		 *
		 * &lt;p&gt;
		 * Signed values need to be at index {@code 0} or require a whitespace character
		 * at {@code index - 1}.
		 *
		 * @param value  the string to check
		 * @param length the length of {@code value} (cached)
		 * @param index  the index to check
		 * @return {@code true} if {@code value} has a signed numeric value at
		 *         {@code index}
		 */
		private boolean isSignedNumeric(final String value, final int length, final int index) {
<span class="nc" id="L195">			final char sign = value.charAt(index);</span>
<span class="nc bnc" id="L196" title="All 10 branches missed.">			if (sign != '-' &amp;&amp; sign != '+' || index &gt; 0 &amp;&amp; !Characters.isAsciiWhitespace(value.charAt(index - 1)) || index + 1 &gt;= length) {</span>
<span class="nc" id="L197">				return false;</span>
			}
<span class="nc" id="L199">			return Characters.isAsciiDigit(value.charAt(index + 1));</span>
		}

		/**
		 * Compares an optionally signed numeric value.
		 *
		 * &lt;p&gt;
		 * This method updates the internal contexts state. It loads one character of
		 * both strings &lt;i&gt;without&lt;/i&gt; validation.
		 *
		 * @return comparison result
		 */
		private int compareSignedNumeric() {
			// Calculate length of the numeric chunks
<span class="nc" id="L213">			final int firstSignedNumericLength = getNumericLength(first, firstLength, firstIndex);</span>
<span class="nc" id="L214">			final int secondSignedNumericLength = getNumericLength(second, secondLength, secondIndex);</span>
			// Return if one is not numeric
<span class="nc bnc" id="L216" title="All 4 branches missed.">			if (firstSignedNumericLength == 0 || secondSignedNumericLength == 0) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">				return firstSignedNumericLength == 0 ? 1 : -1;</span>
			}
			// Handle negative sign
<span class="nc bnc" id="L220" title="All 2 branches missed.">			final boolean firstIsNegative = first.charAt(firstIndex) == '-';</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">			final boolean secondIsNegative = second.charAt(secondIndex) == '-';</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">			if (firstIsNegative != secondIsNegative) {</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">				return firstIsNegative ? -1 : 1;</span>
			}
			// Calculate numeric length without signs and leading zeros
<span class="nc" id="L226">			final int firstNumericLength = getDigitsLength(first, firstIndex, firstSignedNumericLength);</span>
<span class="nc" id="L227">			final int secondNumericLength = getDigitsLength(second, secondIndex, secondSignedNumericLength);</span>
			// Update indexes
<span class="nc" id="L229">			firstIndex += firstSignedNumericLength;</span>
<span class="nc" id="L230">			secondIndex += secondSignedNumericLength;</span>
			// Compare
<span class="nc bnc" id="L232" title="All 2 branches missed.">			return (firstIsNegative ? -1 : 1) * compareNumeric(firstNumericLength, secondNumericLength);</span>
		}

		/**
		 * Returns the length of an optionally signed numeric in {@code value} at
		 * {@code index} or zero.
		 *
		 * @param value  the string to check
		 * @param length the length of {@code value} (cached)
		 * @param index  the index to check
		 * @return length of an optionally signed numeric in {@code value} at
		 *         {@code index} or zero
		 */
		private int getNumericLength(final String value, final int length, final int index) {
<span class="nc" id="L246">			int numericIndex = index;</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">			if (isSignedNumeric(value, length, numericIndex)) {</span>
<span class="nc" id="L248">				numericIndex += 2;</span>
			}
<span class="nc bnc" id="L250" title="All 4 branches missed.">			while (numericIndex &lt; length &amp;&amp; Characters.isAsciiDigit(value.charAt(numericIndex))) {</span>
<span class="nc" id="L251">				numericIndex += 1;</span>
			}
<span class="nc" id="L253">			return numericIndex - index;</span>
		}

		/**
		 * Returns the length of the absolute value of an optionally signed numeric
		 * without leading zeros in {@code value} at {@code index} for signed length
		 * {@code signedNumericLength}.
		 *
		 * &lt;p&gt;
		 * In case the numeric value is zero a length of one is returned.
		 *
		 * &lt;p&gt;
		 * This method does not validate if characters in {@code value} from
		 * {@code index} to length {@code signedNumericLength} are valid numeric values!
		 *
		 * @param value               the string to check
		 * @param index               the index to check
		 * @param signedNumericLength the length of the optionally signed numeric to
		 *                            check (cached)
		 * @return length of the absolute value of an optionally signed numeric without
		 *         leading zeros
		 */
		private int getDigitsLength(final String value, final int index, final int signedNumericLength) {
<span class="nc bnc" id="L276" title="All 2 branches missed.">			for (int numericIndex = 0; numericIndex &lt; signedNumericLength; numericIndex += 1) {</span>
<span class="nc" id="L277">				final char character = value.charAt(index + numericIndex);</span>
<span class="nc bnc" id="L278" title="All 6 branches missed.">				if (character != '0' &amp;&amp; character != '-' &amp;&amp; character != '+') {</span>
<span class="nc" id="L279">					return signedNumericLength - numericIndex;</span>
				}
			}
<span class="nc" id="L282">			return 1;</span>
		}

		/**
		 * Compares numeric values at the current index and of the given lengths.
		 *
		 * &lt;p&gt;
		 * This method requires its arguments to match the rules of
		 * {@link #getNumericLength(String, int, int)}.
		 *
		 * @param firstNumericLength  length of the first numeric
		 * @param secondNumericLength length of the second numeric
		 * @return comparison result
		 */
		private int compareNumeric(final int firstNumericLength, final int secondNumericLength) {
			// Return on different lengths
<span class="nc bnc" id="L298" title="All 2 branches missed.">			if (firstNumericLength != secondNumericLength) {</span>
<span class="nc" id="L299">				return firstNumericLength - secondNumericLength;</span>
			}
			// Compare each numeric character from highest to lowest
<span class="nc bnc" id="L302" title="All 2 branches missed.">			for (int numericIndex = firstNumericLength; numericIndex &gt; 0; numericIndex -= 1) {</span>
<span class="nc" id="L303">				final char firstNumericCharacter = first.charAt(firstIndex - numericIndex);</span>
<span class="nc" id="L304">				final char secondNumericCharacter = second.charAt(secondIndex - numericIndex);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">				if (firstNumericCharacter != secondNumericCharacter) {</span>
<span class="nc" id="L306">					return firstNumericCharacter - secondNumericCharacter;</span>
				}
			}
<span class="nc" id="L309">			return 0;</span>
		}

		/**
		 * Compares a single textual character.
		 *
		 * &lt;p&gt;
		 * This method updates the internal contexts state. It loads one character of
		 * both strings &lt;i&gt;without&lt;/i&gt; validation.
		 *
		 * @return comparison result
		 */
		private int compareText() {
<span class="nc" id="L322">			final char firstCharacter = first.charAt(firstIndex);</span>
<span class="nc" id="L323">			final char secondCharacter = second.charAt(secondIndex);</span>
<span class="nc" id="L324">			firstIndex += 1;</span>
<span class="nc" id="L325">			secondIndex += 1;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">			return isCaseInsensitive() ? Characters.compareIgnoreCase(firstCharacter, secondCharacter) : firstCharacter - secondCharacter;</span>
		}

		/**
		 * Compares the strings if at least one has reached its end.
		 *
		 * @return comparison result
		 */
		private int compareRest() {
<span class="nc" id="L335">			return firstLength - firstIndex - (secondLength - secondIndex);</span>
		}
	}

	/**
	 * Specifies case sensitivity for comparison
	 *
	 * @return {@code true} if comparison should take place case insensitive
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public boolean isCaseInsensitive() {
		return this.caseInsensitive;
	}

	/**
	 * Creates a new {@code NumericTextComparator} instance.
	 *
	 * @param caseInsensitive Specifies case sensitivity for comparison
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private NumericTextComparator(final boolean caseInsensitive) {
		this.caseInsensitive = caseInsensitive;
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>