<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StringConverters.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Parent POM</a> &gt; <a href="../index.html" class="el_bundle">utils</a> &gt; <a href="index.source.html" class="el_package">de.larssh.utils.text</a> &gt; <span class="el_source">StringConverters.java</span></div><h1>StringConverters.java</h1><pre class="source lang-java linenums">// Generated by delombok at Sun Jan 03 20:30:37 UTC 2021
package de.larssh.utils.text;

import java.io.UncheckedIOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * This class contains helper methods for decoding and encoding strings.
 */
public final class StringConverters {
	/**
	 * Decodes {@code value} as Base64 string.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link Base64#getDecoder()} with the char
	 * set {@link Strings#DEFAULT_CHARSET}.
	 *
	 * @param value the value to be decoded
	 * @return the decoded value
	 */
	public static String decodeBase64(final String value) {
<span class="nc" id="L27">		return new String(Base64.getDecoder().decode(value), Strings.DEFAULT_CHARSET);</span>
	}

	/**
	 * Decodes {@code value} using the Base64 MIME type decoding scheme.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link Base64#getMimeDecoder()} with the
	 * char set {@link Strings#DEFAULT_CHARSET}.
	 *
	 * @param value the value to be decoded
	 * @return the decoded value
	 */
	public static String decodeBase64Mime(final String value) {
<span class="nc" id="L41">		return new String(Base64.getMimeDecoder().decode(value), Strings.DEFAULT_CHARSET);</span>
	}

	/**
	 * Decodes {@code value} as Base64 URL and filename-safe string.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link Base64#getUrlDecoder()} with the
	 * char set {@link Strings#DEFAULT_CHARSET}.
	 *
	 * @param value the value to be decoded
	 * @return the decoded value
	 */
	public static String decodeBase64Url(final String value) {
<span class="nc" id="L55">		return new String(Base64.getUrlDecoder().decode(value), Strings.DEFAULT_CHARSET);</span>
	}

	/**
	 * Decodes {@code value} as single CSV value if {@code value} starts with
	 * {@code escaper}. Otherwise {@code value} is returned as-is.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Examples:&lt;/b&gt;
	 * &lt;table&gt;
	 * &lt;caption&gt;Examples&lt;/caption&gt;
	 * &lt;tr&gt;
	 * &lt;th&gt;Parameter&lt;/th&gt;
	 * &lt;th&gt;Return Value&lt;/th&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;EMPTY&lt;/td&gt;
	 * &lt;td&gt;EMPTY&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;abc&lt;/td&gt;
	 * &lt;td&gt;abc&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;&quot;&quot;&lt;/td&gt;
	 * &lt;td&gt;EMPTY&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;&quot;abc&quot;&lt;/td&gt;
	 * &lt;td&gt;abc&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;&quot;abc&quot;&quot;xyz&quot;&lt;/td&gt;
	 * &lt;td&gt;abc&quot;xyz&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;&quot;&quot;&quot;&quot;&lt;/td&gt;
	 * &lt;td&gt;&quot;&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;/table&gt;
	 *
	 * @param value   the value to be decoded
	 * @param escaper the escaping character
	 * @return the decoded value
	 * @throws ParseException if the CSV value ends unexpectedly or some occurrence
	 *                        of {@code escaper} is not escaped correctly
	 */
	@SuppressWarnings(&quot;PMD.CyclomaticComplexity&quot;)
	public static String decodeCsv(final String value, final char escaper) throws ParseException {
<span class="nc bnc" id="L104" title="All 4 branches missed.">		if (value.isEmpty() || value.charAt(0) != escaper) {</span>
<span class="nc" id="L105">			return value;</span>
		}
<span class="nc" id="L107">		final int length = value.length();</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">		if (length &lt; 2) {</span>
<span class="nc" id="L109">			throw new ParseException(&quot;Value starts with the escape character. Expected a matching trailing character, but found none.&quot;);</span>
		}
<span class="nc bnc" id="L111" title="All 2 branches missed.">		if (value.charAt(length - 1) != escaper) {</span>
<span class="nc" id="L112">			throw new ParseException(&quot;Value starts with the escape character. Expected a matching trailing character, but found [%s].&quot;, value.charAt(length - 1));</span>
		}
<span class="nc" id="L114">		int index = 1;</span>
<span class="nc" id="L115">		final StringBuilder builder = new StringBuilder(length - 2);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">		while (index &lt; length - 1) {</span>
<span class="nc" id="L117">			final char character = value.charAt(index);</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">			if (character == escaper) {</span>
<span class="nc" id="L119">				index += 1;</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">				if (index &gt;= length - 1) {</span>
<span class="nc" id="L121">					throw new ParseException(&quot;Unexpected end after escape character in [%s].&quot;, value);</span>
				}
<span class="nc bnc" id="L123" title="All 2 branches missed.">				if (value.charAt(index) != escaper) {</span>
<span class="nc" id="L124">					throw new ParseException(&quot;Unexpected character \&quot;%s\&quot; at index %d after escape character.&quot;, value.charAt(index), index);</span>
				}
			}
<span class="nc" id="L127">			builder.append(character);</span>
<span class="nc" id="L128">			index += 1;</span>
<span class="nc" id="L129">		}</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">		return builder.length() == length ? value : builder.toString();</span>
	}

	/**
	 * Decodes an {@code application/x-www-form-urlencoded} string.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link URLDecoder#decode(String)} with the
	 * char set {@link StandardCharsets#UTF_8} as the
	 * &lt;a href= &quot;https://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars&quot;&gt;
	 * World Wide Web Consortium Recommendation&lt;/a&gt; states that UTF-8 should be
	 * used.
	 *
	 * @param value the value to be decoded
	 * @return the decoded value
	 * @throws ParseException on illegal or incomplete hex characters
	 */
	@SuppressFBWarnings(value = &quot;EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS&quot;, justification = &quot;converting checked to unchecked exception, that should never be thrown at all&quot;)
	public static String decodeUrl(final String value) throws ParseException {
		try {
<span class="nc" id="L150">			return URLDecoder.decode(value, StandardCharsets.UTF_8.name());</span>
<span class="nc" id="L151">		} catch (final IllegalArgumentException e) {</span>
<span class="nc" id="L152">			throw new ParseException(e, &quot;Failed decoding URL.&quot;);</span>
<span class="nc" id="L153">		} catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L154">			throw new UncheckedIOException(e);</span>
		}
	}

	/**
	 * Translates {@code value} into Base64 format.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link Base64#getEncoder()} with the char
	 * set {@link Strings#DEFAULT_CHARSET}.
	 *
	 * @param value the value to be encoded
	 * @return the encoded value
	 */
	public static String encodeBase64(final String value) {
<span class="nc" id="L169">		return new String(Base64.getEncoder().encode(value.getBytes(Strings.DEFAULT_CHARSET)), Strings.DEFAULT_CHARSET);</span>
	}

	/**
	 * Translates {@code value} into Base64 MIME type encoding scheme.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link Base64#getMimeEncoder()} with the
	 * char set {@link Strings#DEFAULT_CHARSET}.
	 *
	 * @param value the value to be encoded
	 * @return the encoded value
	 */
	public static String encodeBase64Mime(final String value) {
<span class="nc" id="L183">		return new String(Base64.getMimeEncoder().encode(value.getBytes(Strings.DEFAULT_CHARSET)), Strings.DEFAULT_CHARSET);</span>
	}

	/**
	 * Translates {@code value} into Base64 URL and filename-safe format.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to using {@link Base64#getUrlEncoder()} with the
	 * charset {@link Strings#DEFAULT_CHARSET}.
	 *
	 * @param value the value to be encoded
	 * @return the encoded value
	 */
	public static String encodeBase64Url(final String value) {
<span class="nc" id="L197">		return new String(Base64.getUrlEncoder().encode(value.getBytes(Strings.DEFAULT_CHARSET)), Strings.DEFAULT_CHARSET);</span>
	}

	/**
	 * Encodes {@code value} into a single CSV value. All occurrences of
	 * {@code escaper} are escaped (doubled). If {@code value} contains
	 * inappropriate characters, it is surrounded by {@code escaper}.
	 *
	 * &lt;p&gt;
	 * Inappropriate characters are {@code '\r'}, {@code '\n'}, {@code escaper} and
	 * {@code separator}. The latter is used for the list of inappropriate
	 * characters only.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Examples:&lt;/b&gt;
	 * &lt;table&gt;
	 * &lt;caption&gt;Examples&lt;/caption&gt;
	 * &lt;tr&gt;
	 * &lt;th&gt;Parameter&lt;/th&gt;
	 * &lt;th&gt;Return Value&lt;/th&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;EMPTY&lt;/td&gt;
	 * &lt;td&gt;EMPTY&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;abc&lt;/td&gt;
	 * &lt;td&gt;abc&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;abc&quot;xyz&lt;/td&gt;
	 * &lt;td&gt;&quot;abc&quot;&quot;xyz&quot;&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;&quot;&lt;/td&gt;
	 * &lt;td&gt;&quot;&quot;&quot;&quot;&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;/table&gt;
	 *
	 * @param value     the value to be encoded
	 * @param escaper   the escaping character
	 * @param separator the separator character
	 * @return the encoded value
	 */
	@SuppressWarnings(&quot;PMD.CyclomaticComplexity&quot;)
	public static String encodeCsv(final String value, final char escaper, final char separator) {
<span class="nc bnc" id="L243" title="All 2 branches missed.">		if (escaper == separator) {</span>
<span class="nc" id="L244">			throw new IllegalArgumentException(&quot;Escape character and separator must not be equal.&quot;);</span>
		}
<span class="nc" id="L246">		final int length = value.length();</span>
<span class="nc" id="L247">		final StringBuilder builder = new StringBuilder(length);</span>
<span class="nc" id="L248">		builder.append(escaper);</span>
<span class="nc" id="L249">		int beginIndex = 0;</span>
<span class="nc" id="L250">		boolean changed = false;</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">		for (int index = 0; index &lt; length; index += 1) {</span>
<span class="nc" id="L252">			final char character = value.charAt(index);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">			if (character == escaper) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">				if (beginIndex &lt; index) {</span>
<span class="nc" id="L255">					builder.append(value, beginIndex, index);</span>
				}
<span class="nc" id="L257">				beginIndex = index + 1;</span>
<span class="nc" id="L258">				builder.append(escaper).append(escaper);</span>
<span class="nc" id="L259">				changed = true;</span>
<span class="nc bnc" id="L260" title="All 6 branches missed.">			} else if (character == separator || character == '\r' || character == '\n') {</span>
<span class="nc" id="L261">				changed = true;</span>
			}
		}
<span class="nc bnc" id="L264" title="All 2 branches missed.">		if (!changed) {</span>
<span class="nc" id="L265">			return value;</span>
		}
<span class="nc bnc" id="L267" title="All 2 branches missed.">		if (beginIndex &lt; length) {</span>
<span class="nc" id="L268">			builder.append(value, beginIndex, length);</span>
		}
<span class="nc" id="L270">		return builder.append(escaper).toString();</span>
	}

	/**
	 * Translates a string into {@code application/x-www-form-urlencoded} format
	 * with the char set {@link StandardCharsets#UTF_8} as the
	 * &lt;a href= &quot;https://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars&quot;&gt;
	 * World Wide Web Consortium Recommendation&lt;/a&gt; states that UTF-8 should be
	 * used.
	 *
	 * @param value the value to be encoded
	 * @return the encoded value
	 */
	@SuppressFBWarnings(value = &quot;EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS&quot;, justification = &quot;converting checked to unchecked exception, that should never be thrown at all&quot;)
	public static String encodeUrl(final String value) {
		try {
<span class="nc" id="L286">			return URLEncoder.encode(value, StandardCharsets.UTF_8.name());</span>
<span class="nc" id="L287">		} catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L288">			throw new UncheckedIOException(e);</span>
		}
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private StringConverters() {
		throw new java.lang.UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>