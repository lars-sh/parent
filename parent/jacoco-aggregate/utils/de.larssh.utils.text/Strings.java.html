<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Strings.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Parent POM</a> &gt; <a href="../index.html" class="el_bundle">utils</a> &gt; <a href="index.source.html" class="el_package">de.larssh.utils.text</a> &gt; <span class="el_source">Strings.java</span></div><h1>Strings.java</h1><pre class="source lang-java linenums">// Generated by delombok at Tue Oct 20 07:11:36 UTC 2020
package de.larssh.utils.text;

import static de.larssh.utils.Collectors.toLinkedHashMap;
import static de.larssh.utils.Finals.constant;
import static java.util.Arrays.asList;
import static java.util.Collections.unmodifiableMap;
import static java.util.stream.Collectors.joining;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Comparator;
import java.util.Formatter;
import java.util.IllegalFormatException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.IntStream;
import de.larssh.utils.Optionals;
import de.larssh.utils.collection.Maps;
import edu.umd.cs.findbugs.annotations.Nullable;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * This class contains helper methods for {@link String}.
 */
@SuppressWarnings({&quot;PMD.ExcessiveImports&quot;, &quot;PMD.GodClass&quot;})
public final class Strings {
	/**
	 * Character to separate strings inside regular expressions
	 */
	private static final String PATTERN_STRING_SEPARATOR = &quot;|&quot;;
	/**
	 * Map of binary units to their factor
	 *
	 * &lt;ul&gt;
	 * &lt;li&gt;{@code K}: {@code 1024}
	 * &lt;li&gt;{@code M}: {@code 1024 * 1024}
	 * &lt;li&gt;{@code G}: {@code 1024 * 1024 * 1024}
	 * &lt;li&gt;...
	 * &lt;/ul&gt;
	 */
<span class="nc" id="L49">	public static final Map&lt;String, BigDecimal&gt; BINARY_UNITS = unmodifiableMap(getBinaryUnits());</span>
	/**
	 * Pattern for parsing binary unit strings
	 */
<span class="nc" id="L53">	private static final Pattern BINARY_UNIT_PATTERN = Pattern.compile(&quot;(?i)^\\s*(?&lt;value&gt;[+-]?\\s*(\\d([\\d_]*\\d)?)?\\.?\\d([\\d_]*\\d)?)\\s*((?&lt;unit&gt;&quot; + BINARY_UNITS.keySet().stream().map(Pattern::quote).collect(joining(PATTERN_STRING_SEPARATOR)) + &quot;)i?)?\\s*$&quot;);</span>
	/**
	 * Map of decimal units to their power of ten
	 *
	 * &lt;ul&gt;
	 * &lt;li&gt;...
	 * &lt;li&gt;{@code m}: {@code -3}
	 * &lt;li&gt;{@code k}: {@code 3}
	 * &lt;li&gt;{@code M}: {@code 6}
	 * &lt;li&gt;...
	 * &lt;/ul&gt;
	 */
	@SuppressWarnings({&quot;checkstyle:MagicNumber&quot;, &quot;checkstyle:MultipleStringLiterals&quot;})
	@SuppressFBWarnings(value = &quot;PSC_PRESIZE_COLLECTIONS&quot;, justification = &quot;this method is called just once (in static initializer); keep code simple&quot;)
<span class="nc" id="L67">	public static final Map&lt;String, Integer&gt; DECIMAL_UNITS = Maps.builder(new LinkedHashMap&lt;String, Integer&gt;()).put(&quot;y&quot;, -24).put(&quot;z&quot;, -21).put(&quot;a&quot;, -18).put(&quot;f&quot;, -15).put(&quot;p&quot;, -12).put(&quot;n&quot;, -9).put(&quot;u&quot;, -6).put(&quot;Î¼&quot;, -6).put(&quot;m&quot;, -3).put(&quot;c&quot;, -2).put(&quot;d&quot;, -1).put(&quot;da&quot;, 1).put(&quot;h&quot;, 2).put(&quot;k&quot;, 3).put(&quot;M&quot;, 6).put(&quot;G&quot;, 9).put(&quot;T&quot;, 12).put(&quot;P&quot;, 15).put(&quot;E&quot;, 18).put(&quot;Z&quot;, 21).put(&quot;Y&quot;, 24).unmodifiable();</span>
	/**
	 * Pattern for parsing decimal unit strings
	 */
<span class="nc" id="L71">	private static final Pattern DECIMAL_UNIT_PATTERN = Pattern.compile(&quot;(?i)^\\s*(?&lt;value&gt;[+-]?\\s*(\\d([\\d_]*\\d)?)?\\.?\\d([\\d_]*\\d)?)\\s*(?&lt;unit&gt;&quot; + DECIMAL_UNITS.keySet().stream().map(Pattern::quote).collect(joining(PATTERN_STRING_SEPARATOR)) + &quot;)?\\s*$&quot;);</span>
	/**
	 * Constant UTF-8 for usage as default char set.
	 *
	 * &lt;p&gt;
	 * Using {@link java.nio.charset.Charset#defaultCharset()} leads to unexpected
	 * compatibility problems. While the new {@link java.nio.file.Files} API has
	 * been changed to use UTF-8 by default, old and third-party implementations
	 * still depend on the default char set or require a custom char set.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Why shouldn't I use {@link StandardCharsets#UTF_8} directly?&lt;/b&gt;&lt;br&gt;
	 * Using {@link StandardCharsets#UTF_8} is bad practice, as it holds
	 * implementation specific information.
	 */
<span class="nc" id="L86">	public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;</span>
	/**
	 * Constant locale as default locale where no language and country is required.
	 *
	 * &lt;p&gt;
	 * Using {@link Locale#getDefault()} leads to unexpected behavior for technical
	 * formatting operations. Therefore this locale specifies a default value.
	 *
	 * &lt;p&gt;
	 * The returned value is {@link Locale#ROOT}.
	 */
<span class="nc" id="L97">	public static final Locale DEFAULT_LOCALE = Locale.ROOT;</span>
	/**
	 * Constant {@code &quot;\n&quot;} &lt;b&gt;for output&lt;/b&gt;. Remember to accept {@code &quot;\r\n&quot;}
	 * and {@code &quot;\r&quot;} on the input side, too!
	 *
	 * &lt;p&gt;
	 * Using {@link System#lineSeparator()} leads to files, which cannot (should
	 * not) be transferred between UNIX and Microsoft Windows systems. To avoid
	 * problems, some developers decided to depend on the UNIX line separator only.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Why shouldn't I use {@code &quot;\n&quot;} directly?&lt;/b&gt;&lt;br&gt;
	 * Using {@code &quot;\n&quot;} is bad practice, as it holds implementation specific
	 * information.
	 */
<span class="nc" id="L112">	public static final String NEW_LINE = constant(&quot;\n&quot;);</span>
	/**
	 * Pattern to retrieve white space characters in binary and decimal unit strings
	 */
<span class="nc" id="L116">	private static final Pattern UNIT_WHITE_SPACE_PATTERN = Pattern.compile(&quot;[\\s_]+&quot;);</span>

	/**
	 * Tests if this string ends with the specified suffix, ignoring case
	 * considerations.
	 *
	 * @param value  string to compare against
	 * @param suffix the suffix.
	 * @return {@code true} if the character sequence represented by the argument is
	 *         a suffix of the character sequence represented by this object,
	 *         ignoring case considerations; {@code false} otherwise.
	 */
	public static boolean endsWithIgnoreCase(final String value, final String suffix) {
<span class="nc" id="L129">		return startsWithIgnoreCase(value, suffix, value.length() - suffix.length());</span>
	}

	/**
	 * Tells whether or not a subsequence {@code input} matches {@code pattern}.
	 *
	 * &lt;p&gt;
	 * Use {@link Patterns#find(Pattern, CharSequence)} if you need a matcher.
	 *
	 * @param input   the input sequence to find the pattern in
	 * @param pattern the matching pattern
	 * @return {@code true} if, and only if, {@code input} matches {@code pattern}
	 */
	public static boolean find(final CharSequence input, final Pattern pattern) {
<span class="nc" id="L143">		return pattern.matcher(input).find();</span>
	}

	/**
	 * Returns a formatted string using the specified format string and
	 * {@code arguments}. In that way this method works &lt;i&gt;similar&lt;/i&gt; to
	 * {@link String#format(String, Object...)}.
	 *
	 * &lt;p&gt;
	 * Here are the differences:
	 * &lt;ul&gt;
	 * &lt;li&gt;In case {@code arguments} is empty, no checks and formatting is
	 * performed. {@code format} is returned immediately and without modification.
	 * &lt;li&gt;{@link #DEFAULT_LOCALE} is used instead of the systems default
	 * {@link Locale}.
	 * &lt;li&gt;On formatting failure no exception is thrown. When used for error
	 * messages this often hides the original error message. Instead a failure
	 * message is returned, containing {@code format}.
	 * &lt;/ul&gt;
	 *
	 * @param format    &lt;a href=&quot;../util/Formatter.html#syntax&quot;&gt;format string&lt;/a&gt;
	 * @param arguments arguments referenced by format specifiers in {@code format}
	 * @return formatted string
	 */
	@SuppressFBWarnings(value = &quot;FORMAT_STRING_MANIPULATION&quot;, justification = &quot;formatting exceptions are catched and handled accordingly&quot;)
	public static String format(final String format, final Object... arguments) {
<span class="nc bnc" id="L169" title="All 2 branches missed.">		if (arguments.length &lt; 1) {</span>
<span class="nc" id="L170">			return format;</span>
		}
<span class="nc" id="L172">		try (Formatter formatter = new Formatter(DEFAULT_LOCALE)) {</span>
<span class="nc" id="L173">			return formatter.format(format, arguments).toString();</span>
<span class="nc" id="L174">		} catch (final IllegalFormatException e) {</span>
<span class="nc" id="L175">			return &quot;Failed formatting string [&quot; + format + &quot;]: &quot; + e.getMessage();</span>
		}
	}

	/**
	 * Returns a map of binary units to their factor for static initialization.
	 *
	 * @return map map of binary units to their factor
	 */
	@SuppressWarnings(&quot;checkstyle:MultipleStringLiterals&quot;)
	private static Map&lt;String, BigDecimal&gt; getBinaryUnits() {
<span class="nc" id="L186">		final List&lt;String&gt; binaryUnits = asList(&quot;K&quot;, &quot;M&quot;, &quot;G&quot;, &quot;T&quot;, &quot;P&quot;, &quot;E&quot;, &quot;Z&quot;, &quot;Y&quot;);</span>
<span class="nc" id="L187">		final BigDecimal oneThousandTwentyFour = new BigDecimal(1024);</span>
<span class="nc" id="L188">		return IntStream.range(0, binaryUnits.size()).boxed().collect(toLinkedHashMap(binaryUnits::get, index -&gt; oneThousandTwentyFour.pow(index + 1)));</span>
	}

	/**
	 * Returns {@code true} if {@code value} consists of whitespace only or equals
	 * {@code null}.
	 *
	 * &lt;p&gt;
	 * This is an optimized way of {@code value.trim().isEmpty()}.
	 *
	 * @param value string
	 * @return {@code true} if {@code value} consists of whitespace only or equals
	 *         {@code null}
	 */
	public static boolean isBlank(@Nullable final CharSequence value) {
<span class="nc bnc" id="L203" title="All 2 branches missed.">		if (value == null) {</span>
<span class="nc" id="L204">			return true;</span>
		}
<span class="nc" id="L206">		final int length = value.length();</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">		for (int index = 0; index &lt; length; index += 1) {</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">			if (!Characters.isAsciiWhitespace(value.charAt(index))) {</span>
<span class="nc" id="L209">				return false;</span>
			}
		}
<span class="nc" id="L212">		return true;</span>
	}

	/**
	 * Tells whether or not {@code input} matches {@code pattern}.
	 *
	 * &lt;p&gt;
	 * Use {@link Patterns#matches(Pattern, CharSequence)} if you need a matcher.
	 *
	 * @param input   the value to match
	 * @param pattern the matching pattern
	 * @return {@code true} if, and only if, {@code input} matches {@code pattern}
	 */
	public static boolean matches(final CharSequence input, final Pattern pattern) {
<span class="nc" id="L226">		return pattern.matcher(input).matches();</span>
	}

	/**
	 * A {@link Comparator} that orders alpha numeric strings in &lt;i&gt;natural&lt;/i&gt;
	 * order, either case sensitive or case insensitive. It is appreciated to use
	 * this kind of ordering for user output.
	 *
	 * &lt;p&gt;
	 * Because numeric values are not deserialized into numeric data types, their
	 * length is not limited. Fractions are not supported and will be handled as two
	 * separate numeric values.
	 *
	 * &lt;p&gt;
	 * Numeric values can have a leading plus or minus sign when following a
	 * whitespace character or at a strings start.
	 *
	 * &lt;p&gt;
	 * The following lists some example values to demonstrate the ordering.
	 * &lt;ul&gt;
	 * &lt;li&gt;Banana -12 Circus
	 * &lt;li&gt;Banana -5 Circus
	 * &lt;li&gt;Banana +5 Circus
	 * &lt;li&gt;Banana 5 Circus
	 * &lt;li&gt;Banana +5 Dolphin
	 * &lt;li&gt;Banana 8 Circus
	 * &lt;li&gt;Banana 12 Circus
	 * &lt;li&gt;Banana-5 Circus
	 * &lt;li&gt;Banana-12 Circus
	 * &lt;li&gt;Banana--5 Circus
	 * &lt;li&gt;Elephant 5 Circus
	 * &lt;/ul&gt;
	 *
	 * &lt;p&gt;
	 * This comparator permits null values.
	 *
	 * &lt;p&gt;
	 * Note that this Comparator does &lt;em&gt;not&lt;/em&gt; take locale into account, and
	 * will result in an unsatisfactory ordering for certain locales.
	 *
	 * @param caseInsensitive {@code true} if comparison should take place case
	 *                        insensitive
	 * @return a {@link Comparator} that orders alpha numeric strings in
	 *         &lt;i&gt;natural&lt;/i&gt; order, either case sensitive or case insensitive. It
	 *         is appreciated to use this kind of ordering for user output.
	 */
	public static Comparator&lt;String&gt; numericTextComparator(final boolean caseInsensitive) {
<span class="nc bnc" id="L273" title="All 2 branches missed.">		return caseInsensitive ? NumericTextComparator.COMPARATOR_CASE_INSENSITIVE : NumericTextComparator.COMPARATOR_CASE_SENSITIVE;</span>
	}

	/**
	 * Parses {@code binaryValue} as binary value with
	 * &lt;ul&gt;
	 * &lt;li&gt;optional sign,
	 * &lt;li&gt;optional fraction
	 * &lt;li&gt;and optional binary unit (case insensitive matching).
	 * &lt;/ul&gt;
	 *
	 * &lt;p&gt;
	 * Binary units multiply by 1024. Though strings with fractions can be parsed,
	 * the resulting value must not contain a fraction part. Numeric values can be
	 * formatted using underscore, just as numeric Java literals can be formatted.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Examples:&lt;/b&gt;
	 * &lt;table&gt;
	 * &lt;caption&gt;Examples&lt;/caption&gt;
	 * &lt;tr&gt;
	 * &lt;th&gt;Parameter&lt;/th&gt;
	 * &lt;th&gt;Calculation&lt;/th&gt;
	 * &lt;th&gt;Return Value&lt;/th&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;-2m&lt;/td&gt;
	 * &lt;td&gt;-2 * 1024 * 1024&lt;/td&gt;
	 * &lt;td&gt;-2 097 152&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;0&lt;/td&gt;
	 * &lt;td&gt;&lt;/td&gt;
	 * &lt;td&gt;0&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;5.4k&lt;/td&gt;
	 * &lt;td&gt;5.4 * 1024&lt;/td&gt;
	 * &lt;td&gt;5529.6 -&amp;gt; ArithmeticException&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;+5_432&lt;/td&gt;
	 * &lt;td&gt;&lt;/td&gt;
	 * &lt;td&gt;5 432&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;/table&gt;
	 *
	 * @param binaryValue binary string
	 * @return binary value
	 * @throws ParseException on parse failure
	 */
	@SuppressWarnings(&quot;checkstyle:MultipleStringLiterals&quot;)
	public static BigInteger parseBinaryUnit(final String binaryValue) throws ParseException {
<span class="nc" id="L326">		final Optional&lt;Matcher&gt; matcher = Patterns.matches(BINARY_UNIT_PATTERN, binaryValue);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">		if (!matcher.isPresent()) {</span>
<span class="nc" id="L328">			throw new ParseException(&quot;Value [%s] does not match binary unit pattern.&quot;, binaryValue);</span>
		}
<span class="nc" id="L330">		final String value = matcher.get().group(&quot;value&quot;);</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">		if (value == null) {</span>
<span class="nc" id="L332">			throw new ParseException(&quot;No binary unit value given in string [%s].&quot;, binaryValue);</span>
		}
<span class="nc" id="L334">		final String unit = matcher.get().group(&quot;unit&quot;);</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">		final BigDecimal multiplicator = unit == null ? BigDecimal.ONE : BINARY_UNITS.get(Strings.toNeutralUpperCase(unit));</span>
<span class="nc" id="L336">		return new BigDecimal(replaceAll(value, UNIT_WHITE_SPACE_PATTERN, &quot;&quot;)).multiply(multiplicator).toBigIntegerExact();</span>
	}

	/**
	 * Parses {@code decimalValue} as decimal value with
	 * &lt;ul&gt;
	 * &lt;li&gt;optional sign,
	 * &lt;li&gt;optional fraction
	 * &lt;li&gt;and optional decimal unit (case insensitive matching - where possible).
	 * &lt;/ul&gt;
	 *
	 * &lt;p&gt;
	 * Numeric values can be formatted using underscore, just as numeric Java
	 * literals can be formatted.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Examples:&lt;/b&gt;
	 * &lt;table&gt;
	 * &lt;caption&gt;Examples&lt;/caption&gt;
	 * &lt;tr&gt;
	 * &lt;th&gt;Parameter&lt;/th&gt;
	 * &lt;th&gt;Return Value&lt;/th&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;-2m&lt;/td&gt;
	 * &lt;td&gt;-0.002&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;0&lt;/td&gt;
	 * &lt;td&gt;0&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;5.4k&lt;/td&gt;
	 * &lt;td&gt;5 400&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;+5_432&lt;/td&gt;
	 * &lt;td&gt;5 432&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;/table&gt;
	 *
	 * @param decimalValue decimal string
	 * @return decimal value
	 * @throws ParseException on parse failure
	 */
	@SuppressWarnings(&quot;checkstyle:MultipleStringLiterals&quot;)
	public static BigDecimal parseDecimalUnit(final String decimalValue) throws ParseException {
<span class="nc" id="L383">		final Optional&lt;Matcher&gt; matcher = Patterns.matches(DECIMAL_UNIT_PATTERN, decimalValue);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">		if (!matcher.isPresent()) {</span>
<span class="nc" id="L385">			throw new ParseException(&quot;Value [%s] does not match decimal unit pattern.&quot;, decimalValue);</span>
		}
<span class="nc" id="L387">		final String value = matcher.get().group(&quot;value&quot;);</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">		if (value == null) {</span>
<span class="nc" id="L389">			throw new ParseException(&quot;No decimal unit value given in string [%s].&quot;, decimalValue);</span>
		}
<span class="nc" id="L391">		final String unit = matcher.get().group(&quot;unit&quot;);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">		final int powerOfTen = Optionals.getFirst(Objects::nonNull, () -&gt; unit == null ? 0 : null, () -&gt; DECIMAL_UNITS.get(unit), () -&gt; DECIMAL_UNITS.get(Strings.toNeutralUpperCase(unit)), () -&gt; DECIMAL_UNITS.get(Strings.toNeutralLowerCase(unit))).orElseThrow(() -&gt; new ParseException(&quot;Found unexpected decimal unit [%s].&quot;, unit));</span>
<span class="nc" id="L393">		return new BigDecimal(replaceAll(value, UNIT_WHITE_SPACE_PATTERN, &quot;&quot;)).scaleByPowerOfTen(powerOfTen);</span>
	}

	/**
	 * Replaces the first subsequence of {@code input} that matches {@code pattern}
	 * with {@code replacement}.
	 *
	 * &lt;p&gt;
	 * Note that {@code replacement} is not a literal replacement string.
	 * Backslashes ({@code \}) and dollar signs ({@code $}) may be treated
	 * differently. Quote unknown literal replacement strings using
	 * {@link Matcher#quoteReplacement(String)}.
	 *
	 * @param input       the value to match
	 * @param pattern     the matching pattern
	 * @param replacement the replacement string
	 * @return the string constructed by replacing each matching subsequence by the
	 *         replacement string, substituting captured subsequences as needed
	 */
	public static String replaceFirst(final CharSequence input, final Pattern pattern, final String replacement) {
<span class="nc" id="L413">		return pattern.matcher(input).replaceFirst(replacement);</span>
	}

	/**
	 * Replaces every subsequence of {@code input} that matches {@code pattern} with
	 * {@code replacement}.
	 *
	 * &lt;p&gt;
	 * Note that {@code replacement} is not a literal replacement string.
	 * Backslashes ({@code \}) and dollar signs ({@code $}) may be treated
	 * differently. Quote unknown literal replacement strings using
	 * {@link Matcher#quoteReplacement(String)}.
	 *
	 * @param input       the value to match
	 * @param pattern     the matching pattern
	 * @param replacement the replacement string
	 * @return the string constructed by replacing each matching subsequence by the
	 *         replacement string, substituting captured subsequences as needed
	 */
	public static String replaceAll(final CharSequence input, final Pattern pattern, final String replacement) {
<span class="nc" id="L433">		return pattern.matcher(input).replaceAll(replacement);</span>
	}

	/**
	 * Tests if this string starts with the specified prefix, ignoring case
	 * considerations.
	 *
	 * @param value  string to compare against
	 * @param prefix the prefix.
	 * @return {@code true} if the character sequence represented by the argument is
	 *         a prefix of the character sequence represented by this string,
	 *         ignoring case considerations; {@code false} otherwise.
	 */
	public static boolean startsWithIgnoreCase(final String value, final String prefix) {
<span class="nc" id="L447">		return startsWithIgnoreCase(value, prefix, 0);</span>
	}

	/**
	 * Tests if the substring of this string beginning at the specified index starts
	 * with the specified prefix, ignoring case considerations.
	 *
	 * @param value  string to compare against
	 * @param prefix the prefix.
	 * @param offset where to begin looking in this string.
	 * @return {@code true} if the character sequence represented by the argument is
	 *         a prefix of the substring of this object starting at index
	 *         {@code offset}, ignoring case considerations; {@code false}
	 *         otherwise. The result is {@code false} if {@code offset} is negative
	 *         or greater than the length of this {@code String} object.
	 */
	public static boolean startsWithIgnoreCase(final String value, final String prefix, final int offset) {
<span class="nc" id="L464">		final int prefixLength = prefix.length();</span>
<span class="nc bnc" id="L465" title="All 4 branches missed.">		if (offset &lt; 0 || offset + prefixLength &gt; value.length()) {</span>
<span class="nc" id="L466">			return false;</span>
		}
<span class="nc bnc" id="L468" title="All 2 branches missed.">		for (int index = 0; index &lt; prefixLength; index += 1) {</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">			if (!Characters.equalsIgnoreCase(value.charAt(offset + index), prefix.charAt(index))) {</span>
<span class="nc" id="L470">				return false;</span>
			}
		}
<span class="nc" id="L473">		return true;</span>
	}

	/**
	 * Converts all of the characters in {@code value} to lower case using
	 * {@link #DEFAULT_LOCALE}. This method is equivalent to
	 * {@code toLowerCase(Locale.ROOT)}.
	 *
	 * @param value string to convert
	 * @return converted string
	 */
	public static String toNeutralLowerCase(final String value) {
<span class="nc" id="L485">		return value.toLowerCase(DEFAULT_LOCALE);</span>
	}

	/**
	 * Converts {@code value} to title case by converting its first character using
	 * {@link Character#toTitleCase(char)} and following to lower case using
	 * {@link #DEFAULT_LOCALE}.
	 *
	 * @param value string to convert
	 * @return converted string
	 */
	public static String toNeutralTitleCase(final String value) {
<span class="nc bnc" id="L497" title="All 2 branches missed.">		if (value.isEmpty()) {</span>
<span class="nc" id="L498">			return value;</span>
		}
<span class="nc" id="L500">		final int length = value.length();</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">		if (length == 1) {</span>
<span class="nc" id="L502">			return Character.toString(Character.toTitleCase(value.charAt(0)));</span>
		}
<span class="nc" id="L504">		final String lowerCase = value.toLowerCase(DEFAULT_LOCALE);</span>
<span class="nc" id="L505">		return new StringBuilder(length).append(Character.toTitleCase(value.charAt(0))).append(lowerCase, 1, lowerCase.length()).toString();</span>
	}

	/**
	 * Converts all of the characters in {@code value} to upper case using
	 * {@link #DEFAULT_LOCALE}. This method is equivalent to
	 * {@code toUpperCase(Locale.ROOT)}.
	 *
	 * @param value string to convert
	 * @return converted string
	 */
	public static String toNeutralUpperCase(final String value) {
<span class="nc" id="L517">		return value.toUpperCase(DEFAULT_LOCALE);</span>
	}

	/**
	 * Returns a string similar to {@code value}, but with any leading whitespace
	 * removed.
	 *
	 * &lt;p&gt;
	 * This method works similar to {@link String#trim()}, though it handles only
	 * the strings start.
	 *
	 * &lt;p&gt;
	 * Whitespace characters are recognized using
	 * {@link Characters#isAsciiWhitespace(char)}.
	 *
	 * @param value value
	 * @return left trimmed value
	 */
	public static String trimStart(final String value) {
<span class="nc" id="L536">		int start = 0;</span>
<span class="nc" id="L537">		final int length = value.length();</span>
<span class="nc bnc" id="L538" title="All 4 branches missed.">		while (start &lt; length &amp;&amp; Characters.isAsciiWhitespace(value.charAt(start))) {</span>
<span class="nc" id="L539">			start += 1;</span>
		}
<span class="nc" id="L541">		return value.substring(start);</span>
	}

	/**
	 * Returns a string similar to {@code value}, but with any trailing whitespace
	 * removed.
	 *
	 * &lt;p&gt;
	 * This method works similar to {@link String#trim()}, though it handles only
	 * the strings end.
	 *
	 * &lt;p&gt;
	 * Whitespace characters are recognized using
	 * {@link Characters#isAsciiWhitespace(char)}.
	 *
	 * @param value value
	 * @return left trimmed value
	 */
	public static String trimEnd(final String value) {
<span class="nc" id="L560">		int end = value.length();</span>
<span class="nc bnc" id="L561" title="All 4 branches missed.">		while (end &gt; 0 &amp;&amp; Characters.isAsciiWhitespace(value.charAt(end - 1))) {</span>
<span class="nc" id="L562">			end -= 1;</span>
		}
<span class="nc" id="L564">		return value.substring(0, end);</span>
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private Strings() {
		throw new java.lang.UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>